// server.js - Backend con sistema giacenze per settimana
require('dotenv').config();

const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const xlsx = require('xlsx');
const fileUpload = require('express-fileupload');

const app = express();
const PORT = process.env.PORT || 7070;
const JWT_SECRET = process.env.JWT_SECRET || 'giacenze-default-secret-key-molto-lunga-per-sicurezza-2024';

app.use(cors());
app.use(express.json());
app.use(fileUpload({
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB max file size
  abortOnLimit: true
}));

const corsOptions = {
  origin: [
    'http://localhost:3000', // Development
    'https://resourceful-serenity-production.up.railway.app' // Production
  ],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
};

app.use(cors(corsOptions));

// Connessione MongoDB
const MONGODB_URI = process.env.MONGODB_URI || "mongodb://localhost:27017/giacenze"
mongoose.connect(MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true
});

// Schema aggiornati
const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  role: { type: String, enum: ['admin', 'user'], default: 'user' }
}, { timestamps: true });

const productSchema = new mongoose.Schema({
  nome: { type: String, required: true },
  codice: { type: String, trim: true },
  descrizione: String,
  unita: { type: String, default: 'pz' },
  categoria: String,
  attivo: { type: Boolean, default: true }
}, { timestamps: true });

const poloSchema = new mongoose.Schema({
  nome: { type: String, required: true },
  descrizione: String,
  indirizzo: String,
  coordinate: {
    lat: { type: Number },
    lng: { type: Number }
  },
  attivo: { type: Boolean, default: true }
}, { timestamps: true });

const mezzoSchema = new mongoose.Schema({
  nome: { type: String, required: true },
  targa: String,
  tipo: String,
  marca: String,
  modello: String,
  descrizione: String,
  attivo: { type: Boolean, default: true }
}, { timestamps: true });

const settimanaSchema = new mongoose.Schema({
  numero: { type: Number, required: true },
  anno: { type: Number, required: true },
  dataInizio: { type: Date, required: true },
  dataFine: { type: Date, required: true },
  attiva: { type: Boolean, default: true }
}, { timestamps: true });

// const assegnazioneSchema = new mongoose.Schema({
//   userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
//   poloId: { type: mongoose.Schema.Types.ObjectId, ref: 'Polo', required: true },
//   mezzoId: { type: mongoose.Schema.Types.ObjectId, ref: 'Mezzo', required: true },
//   settimanaId: { type: mongoose.Schema.Types.ObjectId, ref: 'Settimana', required: true },
//   postazioneId: { type: mongoose.Schema.Types.ObjectId, ref: 'Postazione' },
//   attiva: { type: Boolean, default: true },
//   createdBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
// }, { timestamps: true });
// // Indici e vincoli
// assegnazioneSchema.index({ 
//   userId: 1, 
//   settimanaId: 1 
// }, { 
//   unique: true,
//   partialFilterExpression: { attiva: true }
// });
// 19 luglio

// const assegnazioneSchema = new mongoose.Schema({
//   userId: { 
//     type: mongoose.Schema.Types.ObjectId, 
//     ref: 'User', 
//     required: true 
//   },
//   poloId: { 
//     type: mongoose.Schema.Types.ObjectId, 
//     ref: 'Polo', 
//     required: true 
//   },
//   mezzoId: { 
//     type: mongoose.Schema.Types.ObjectId, 
//     ref: 'Mezzo', 
//     required: true 
//   },
//   settimanaId: { 
//     type: mongoose.Schema.Types.ObjectId, 
//     ref: 'Settimana', 
//     required: true 
//   },
//   postazioneId: { 
//     type: mongoose.Schema.Types.ObjectId, 
//     ref: 'Postazione' 
//   },
//   // Array di ordini assegnati
//   ordini: [{
//     ordineId: { 
//       type: mongoose.Schema.Types.ObjectId, 
//       ref: 'Ordine', 
//       required: true 
//     },
//     dataAssegnazione: { 
//       type: Date, 
//       default: Date.now 
//     },
//     priorita: { 
//       type: Number, 
//       default: 1,
//       min: 1
//     },
//     stato: { 
//       type: String, 
//       enum: ['ASSEGNATO', 'IN_CORSO', 'COMPLETATO', 'ANNULLATO'], 
//       default: 'ASSEGNATO' 
//     },
//     note: { 
//       type: String,
//       trim: true
//     },
//     tempoStimato: { 
//       type: Number, // override del tempo stimato dell'ordine
//       min: 1
//     },
//     dataInizio: { type: Date },
//     dataFine: { type: Date },
//     kmPercorsi: { type: Number, min: 0 },
//     costoCarburante: { type: Number, min: 0 }
//   }],
//   // Pianificazione
//   programmazione: {
//     oraInizio: { type: String }, // formato HH:MM
//     oraFine: { type: String },   // formato HH:MM
//     pausePianificate: [{
//       oraInizio: { type: String },
//       oraFine: { type: String },
//       motivo: { type: String }
//     }],
//     percorsoOptimizzato: { type: Boolean, default: false },
//     distanzaTotaleKm: { type: Number, min: 0 }
//   },
//   // Stato generale dell'assegnazione
//   attiva: { 
//     type: Boolean, 
//     default: true 
//   },
//   // Statistiche calcolate automaticamente
//   stats: {
//     totaleOrdini: { type: Number, default: 0 },
//     ordiniCompletati: { type: Number, default: 0 },
//     ordiniInCorso: { type: Number, default: 0 },
//     ordiniAnnullati: { type: Number, default: 0 },
//     tempoTotaleStimato: { type: Number, default: 0 }, // in minuti
//     tempoTotaleEffettivo: { type: Number, default: 0 }, // in minuti
//     valoreCommercialeAssegnato: { type: Number, default: 0 },
//     valoreCompletato: { type: Number, default: 0 },
//     efficienzaPercentuale: { type: Number, default: 0 }, // completati/totali * 100
//     mediaTempoPerOrdine: { type: Number, default: 0 }
//   },
//   createdBy: { 
//     type: mongoose.Schema.Types.ObjectId, 
//     ref: 'User' 
//   },
//   lastModifiedBy: { 
//     type: mongoose.Schema.Types.ObjectId, 
//     ref: 'User' 
//   }
// }, { 
//   timestamps: true 
// });


const assegnazioneSchema = new mongoose.Schema({
  userId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  poloId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Polo', 
    required: true 
  },
  mezzoId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Mezzo', 
    required: true 
  },
  settimanaId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Settimana', 
    required: true 
  },
  postazioneId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Postazione' 
  },
  // ‚úÖ NUOVI CAMPI AGGIUNTI
  ordine: { 
    type: String,
    default: null
  },
  rdt: { 
    type: String,
    default: null
  },
  // CAMPI ESISTENTI
  attiva: { 
    type: Boolean, 
    default: true 
  },
  createdBy: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User' 
  }
}, { 
  timestamps: true 
});

// Indici esistenti + nuovi per i campi aggiunti
assegnazioneSchema.index({ 
  userId: 1, 
  settimanaId: 1 
}, { 
  unique: true,
  partialFilterExpression: { attiva: true }
});

assegnazioneSchema.index({ poloId: 1, settimanaId: 1 });
assegnazioneSchema.index({ mezzoId: 1, settimanaId: 1 });

// ‚úÖ NUOVI INDICI per ricerca per Ordine e RDT
assegnazioneSchema.index({ ordine: 1 });
assegnazioneSchema.index({ rdt: 1 });
assegnazioneSchema.index({ ordine: 1, rdt: 1 });


const ordineSchema = new mongoose.Schema({
  numero: { 
    type: String, 
    required: true, 
    unique: true,
    trim: true
  },
  cliente: { 
    type: String, 
    required: true,
    trim: true
  },
  descrizione: { 
    type: String,
    trim: true
  },
  dataConsegna: { 
    type: Date, 
    required: true 
  },
  indirizzo: {
    via: { type: String, trim: true },
    citta: { type: String, trim: true },
    cap: { type: String, trim: true },
    provincia: { type: String, trim: true },
    coordinate: {
      lat: { type: Number },
      lng: { type: Number }
    }
  },
  priorita: { 
    type: String, 
    enum: ['BASSA', 'MEDIA', 'ALTA', 'URGENTE'], 
    default: 'MEDIA' 
  },
  stato: { 
    type: String, 
    enum: ['CREATO', 'ASSEGNATO', 'IN_CORSO', 'COMPLETATO', 'ANNULLATO'], 
    default: 'CREATO' 
  },
  note: { 
    type: String,
    trim: true
  },
  prodotti: [{
    productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product' },
    nome: { type: String, required: true, trim: true },
    quantita: { type: Number, required: true, min: 0 },
    quantitaMinima: { type: Number, min: 0, default: 0 },
    unita: { type: String, default: 'pz', trim: true },
    prezzo: { type: Number, min: 0 },
    note: { type: String, trim: true }
  }],
  valore: { 
    type: Number, 
    default: 0,
    min: 0
  },
  tempoStimato: { 
    type: Number, // in minuti
    default: 60,
    min: 1
  },
  contatti: {
    telefono: { type: String, trim: true },
    email: { type: String, trim: true, lowercase: true },
    referente: { type: String, trim: true }
  },
  documenti: [{
    nome: { type: String, required: true },
    url: { type: String, required: true },
    tipo: { type: String, enum: ['CONTRATTO', 'FATTURA', 'DDT', 'ALTRO'], default: 'ALTRO' },
    dataCaricamento: { type: Date, default: Date.now }
  }],
  attivo: { 
    type: Boolean, 
    default: true 
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  lastModifiedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  operatoreId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }
}, {
  timestamps: true
});

// Assicura indice univoco sul campo numero per ordini
ordineSchema.index({ numero: 1 }, { unique: true });

// MODIFICATO: Schema giacenze con riferimento alla settimana
const giacenzaUtenteSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
  settimanaId: { type: mongoose.Schema.Types.ObjectId, ref: 'Settimana' }, // NUOVO: riferimento settimana
  quantitaAssegnata: { type: Number, required: true, default: 0 },
  quantitaDisponibile: { type: Number, required: true, default: 0 },
  quantitaMinima: { type: Number, required: true, default: 0 },
  dataAssegnazione: { type: Date, default: Date.now },
  assegnatoDa: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  note: String,
  attiva: { type: Boolean, default: true },
  // NUOVO: flag per giacenza globale (vale per tutte le settimane)
  isGlobale: { type: Boolean, default: true }
}, { timestamps: true });

const utilizzoSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
  giacenzaUtenteId: { type: mongoose.Schema.Types.ObjectId, ref: 'GiacenzaUtente', required: true },
  assegnazioneId: { type: mongoose.Schema.Types.ObjectId, ref: 'Assegnazione' },
  quantitaUtilizzata: { type: Number, required: true },
  quantitaPrimaDellUso: Number,
  quantitaRimasta: Number,
  dataUtilizzo: { type: Date, default: Date.now },
  settimanaId: { type: mongoose.Schema.Types.ObjectId, ref: 'Settimana' },
  poloId: { type: mongoose.Schema.Types.ObjectId, ref: 'Polo' },
  mezzoId: { type: mongoose.Schema.Types.ObjectId, ref: 'Mezzo' },
  postazioneId: { type: mongoose.Schema.Types.ObjectId, ref: 'Postazione' },
  note: { type: String, default: '' }  // ‚Üê AGGIUNTO QUESTO CAMPO
}, { timestamps: true });

const aggiuntaSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
  giacenzaUtenteId: { type: mongoose.Schema.Types.ObjectId, ref: 'GiacenzaUtente', required: true },
  assegnazioneId: { type: mongoose.Schema.Types.ObjectId, ref: 'Assegnazione' },
  quantitaAggiunta: { type: Number, required: true },
  quantitaPrimaDellUso: Number,
  quantitaRimasta: Number,
  dataUtilizzo: { type: Date, default: Date.now },
  settimanaId: { type: mongoose.Schema.Types.ObjectId, ref: 'Settimana' },
  poloId: { type: mongoose.Schema.Types.ObjectId, ref: 'Polo' },
  mezzoId: { type: mongoose.Schema.Types.ObjectId, ref: 'Mezzo' }
}, { timestamps: true });

// Schema ricariche
const ricaricaGiacenzaSchema = new mongoose.Schema({
  giacenzaUtenteId: { type: mongoose.Schema.Types.ObjectId, ref: 'GiacenzaUtente', required: true },
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
  quantitaPrecedente: { type: Number, required: true },
  quantitaAggiunta: { type: Number, required: true },
  quantitaNuova: { type: Number, required: true },
  motivazione: { type: String, default: 'Ricarica manuale' },
  dataRicarica: { type: Date, default: Date.now },
  eseguitoDa: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true }
}, { timestamps: true });



const postazioneSchema = new mongoose.Schema({
  nome: { type: String, required: true, trim: true },
  descrizione: { type: String, trim: true },
  poloId: { type: mongoose.Schema.Types.ObjectId, ref: 'Polo', required: true }, // ‚Üê CAMBIATO: collegato a POLO
  indirizzo: { type: String, trim: true },
  coordinate: {
    lat: { type: Number },
    lng: { type: Number }
  },
  capacitaPersone: { type: Number, default: 1 },
  attrezzature: [{ type: String, trim: true }],
  note: { type: String, trim: true },
  attiva: { type: Boolean, default: true },
  createdBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
}, { timestamps: true });

// Indice composito per evitare duplicati nome-polo
postazioneSchema.index({ nome: 1, poloId: 1 }, { unique: true });

// Modello


// Modelli
const User = mongoose.model('User', userSchema);
const Product = mongoose.model('Product', productSchema);
const Polo = mongoose.model('Polo', poloSchema);
const Mezzo = mongoose.model('Mezzo', mezzoSchema);
const Settimana = mongoose.model('Settimana', settimanaSchema);
const Assegnazione = mongoose.model('Assegnazione', assegnazioneSchema);
const GiacenzaUtente = mongoose.model('GiacenzaUtente', giacenzaUtenteSchema);
const Utilizzo = mongoose.model('Utilizzo', utilizzoSchema);
const Aggiunta = mongoose.model('Aggiunta', aggiuntaSchema);
const Ordine = mongoose.model('Ordine', ordineSchema);

// Rimuovi indice obsoleto se esiste
(async () => {
  try {
    await Ordine.collection.dropIndex('numeroOrdine_1');
    console.log('‚úÖ Indice obsoleto numeroOrdine_1 rimosso');
  } catch (err) {
    if (err.code === 27 || err.message.includes('index not found')) {
      console.log('‚ÑπÔ∏è Indice numeroOrdine_1 non trovato (gi√† rimosso)');
    } else {
      console.log('‚ö†Ô∏è Errore rimozione indice:', err.message);
    }
  }
})();

// Schema RDT (Richiesta Di Trasferimento)
const rdtSchema = new mongoose.Schema({
  numero: { 
    type: String, 
    required: true, 
    unique: true,
    trim: true
  },
  cliente: { 
    type: String, 
    required: true,
    trim: true
  },
  dataConsegna: { 
    type: Date, 
    required: true 
  },
  priorita: { 
    type: String, 
    enum: ['BASSA', 'MEDIA', 'ALTA', 'URGENTE'], 
    default: 'MEDIA' 
  },
  stato: { 
    type: String, 
    enum: ['CREATO', 'ASSEGNATO', 'IN_CORSO', 'COMPLETATO', 'ANNULLATO'], 
    default: 'CREATO' 
  },
  prodotti: [{
    productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product' },
    nome: { type: String, required: true, trim: true },
    quantita: { type: Number, required: true, min: 0 },
    quantitaMinima: { type: Number, min: 0, default: 0 },
    unita: { type: String, default: 'pz', trim: true },
    prezzo: { type: Number, min: 0 },
    note: { type: String, trim: true }
  }],
  valore: { 
    type: Number, 
    default: 0, 
    min: 0 
  },
  tempoStimato: { 
    type: Number, 
    default: 60, 
    min: 0 
  },
  indirizzo: {
    via: { type: String, trim: true },
    citta: { type: String, trim: true },
    cap: { type: String, trim: true },
    provincia: { type: String, trim: true },
    coordinate: {
      lat: Number,
      lng: Number
    }
  },
  contatti: {
    telefono: { type: String, trim: true },
    email: { type: String, trim: true, lowercase: true },
    referente: { type: String, trim: true }
  },
  note: { 
    type: String,
    trim: true
  },
  documenti: [{
    nome: { type: String, required: true },
    url: { type: String, required: true },
    tipo: { type: String, enum: ['CONTRATTO', 'FATTURA', 'PREVENTIVO', 'ALTRO'], default: 'ALTRO' },
    dataCaricamento: { type: Date, default: Date.now }
  }],
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  lastModifiedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  operatoreId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  deleted: {
    type: Boolean,
    default: false
  },
  deletedAt: Date,
  deletedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }
}, {
  timestamps: true
});

// Indici per performance
rdtSchema.index({ numero: 1 });
rdtSchema.index({ cliente: 1 });
rdtSchema.index({ stato: 1 });
rdtSchema.index({ priorita: 1 });
rdtSchema.index({ dataConsegna: 1 });
rdtSchema.index({ createdAt: -1 });
rdtSchema.index({ deleted: 1 });

const RDT = mongoose.model('RDT', rdtSchema);
const RicaricaGiacenza = mongoose.model('RicaricaGiacenza', ricaricaGiacenzaSchema);
const Postazione = mongoose.model('Postazione', postazioneSchema);

// Schema Cliente
const clienteSchema = new mongoose.Schema({
  nome: { type: String, required: true, trim: true },
  email: { type: String, trim: true },
  telefono: { type: String, trim: true },
  indirizzo: { type: String, trim: true },
  citta: { type: String, trim: true },
  cap: { type: String, trim: true },
  partitaIva: { type: String, trim: true },
  codiceFiscale: { type: String, trim: true },
  note: { type: String, trim: true },
  attivo: { type: Boolean, default: true }
}, { timestamps: true });

const Cliente = mongoose.model('Cliente', clienteSchema);
// Middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ message: 'Token di accesso richiesto' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Token non valido' });
    }
    req.user = user;
    next();
  });
};

const requireAdmin = (req, res, next) => {
  if (req.user.role !== 'admin') {
    return res.status(403).json({ message: 'Accesso negato: privilegi admin richiesti' });
  }
  next();
};

// ROUTES

// Auth Routes
app.post('/api/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    const user = await User.findOne({ username });
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ message: 'Credenziali non valide' });
    }
    
    const token = jwt.sign(
      { userId: user._id, username: user.username, role: user.role },
      JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    res.json({ token, user: { id: user._id, username: user.username, role: user.role } });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Products Routes
app.get('/api/products', authenticateToken, async (req, res) => {
  try {
    const products = await Product.find({ attivo: true });
    res.json(products);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

app.get('/api/my-giacenze', authenticateToken, async (req, res) => {
  try {
    const { 
      settimanaId, 
      productId, 
      stato, 
      searchTerm,
      quantitaAssegnataMin,
      quantitaAssegnataMax,
      quantitaDisponibileMin,
      quantitaDisponibileMax,
      sogliaMinimaMin,
      sogliaMinimaMax
    } = req.query;
    
    let filter = { 
      attiva: true 
    };
    
    // Filtro sempre per utente corrente
    filter.userId = req.user.userId;
    
    // Filtro per settimana specifica se fornita
    if (settimanaId) {
      filter.settimanaId = settimanaId;
    }
    
    // NUOVO: Filtro per prodotto specifico
    if (productId) {
      filter.productId = productId;
    }
    
    console.log('üîç Filtri applicati:', { 
      settimanaId, 
      productId, 
      stato, 
      searchTerm,
      ranges: {
        quantitaAssegnataMin,
        quantitaAssegnataMax,
        quantitaDisponibileMin,
        quantitaDisponibileMax,
        sogliaMinimaMin,
        sogliaMinimaMax
      }
    });
    
    const giacenze = await GiacenzaUtente.find(filter)
      .populate('productId', 'nome codice descrizione unita categoria')
      .populate('assegnatoDa', 'username')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .sort({ 'productId.nome': 1 });

    let filteredGiacenze = giacenze;

    // NUOVO: Filtri aggiuntivi (lato server per performance)
    
    // Filtro per stato (critico/ok)
    if (stato) {
      if (stato === 'critico') {
        filteredGiacenze = filteredGiacenze.filter(g => 
          g.quantitaDisponibile <= g.quantitaMinima
        );
      } else if (stato === 'ok') {
        filteredGiacenze = filteredGiacenze.filter(g => 
          g.quantitaDisponibile > g.quantitaMinima
        );
      }
    }

    // Filtro ricerca libera
    if (searchTerm) {
      const term = searchTerm.toLowerCase();
      filteredGiacenze = filteredGiacenze.filter(g => 
        g.productId?.nome.toLowerCase().includes(term) ||
        g.productId?.categoria.toLowerCase().includes(term) ||
        g.productId?.descrizione?.toLowerCase().includes(term) ||
        g.productId?.unita.toLowerCase().includes(term) ||
        g.note?.toLowerCase().includes(term)
      );
    }

    // Filtri numerici per quantit√†
    if (quantitaAssegnataMin) {
      const min = parseInt(quantitaAssegnataMin);
      filteredGiacenze = filteredGiacenze.filter(g => g.quantitaAssegnata >= min);
    }
    
    if (quantitaAssegnataMax) {
      const max = parseInt(quantitaAssegnataMax);
      filteredGiacenze = filteredGiacenze.filter(g => g.quantitaAssegnata <= max);
    }

    if (quantitaDisponibileMin) {
      const min = parseInt(quantitaDisponibileMin);
      filteredGiacenze = filteredGiacenze.filter(g => g.quantitaDisponibile >= min);
    }
    
    if (quantitaDisponibileMax) {
      const max = parseInt(quantitaDisponibileMax);
      filteredGiacenze = filteredGiacenze.filter(g => g.quantitaDisponibile <= max);
    }

    if (sogliaMinimaMin) {
      const min = parseInt(sogliaMinimaMin);
      filteredGiacenze = filteredGiacenze.filter(g => g.quantitaMinima >= min);
    }
    
    if (sogliaMinimaMax) {
      const max = parseInt(sogliaMinimaMax);
      filteredGiacenze = filteredGiacenze.filter(g => g.quantitaMinima <= max);
    }

    console.log(`üìä Risultati: ${filteredGiacenze.length} di ${giacenze.length} giacenze`);

    res.json(filteredGiacenze);
  } catch (error) {
    console.error('‚ùå Errore caricamento giacenze utente:', error);
    res.status(500).json({ message: error.message });
  }
});
// MODIFICATA: Usa prodotto con supporto multi-settimana

app.post('/api/add-product', authenticateToken, async (req, res) => {
  try {
    const { productId, quantitaAggiunta, assegnazioneId, postazioneId } = req.body;

    // Trova giacenza personale
    const giacenza = await GiacenzaUtente.findOne({
      userId: req.user.userId,
      productId,
      attiva: true
    });

    if (!giacenza) {
      return res.status(404).json({ message: 'Giacenza non trovata' });
    }

    // Costruisci query per trovare ultimo utilizzo
    const query = {
      userId: req.user.userId,
      productId
    };

    // Filtra per postazione se fornita
    if (postazioneId) {
      query.postazioneId = postazioneId;
    }

    // Trova ultimo utilizzo (filtrato per postazione se specificata)
    const ultimoUtilizzo = await Utilizzo.findOne(query).sort({ createdAt: -1 });

    if (!ultimoUtilizzo) {
      return res.status(404).json({
        message: postazioneId
          ? 'Nessun utilizzo da annullare per questa postazione'
          : 'Nessun utilizzo da annullare'
      });
    }

    // Aggiunge la quantit√†
    giacenza.quantitaDisponibile += quantitaAggiunta;
    await giacenza.save();

    // Rimuove l'ultimo utilizzo
    await Utilizzo.findByIdAndDelete(ultimoUtilizzo._id);

    res.status(200).json({
      message: 'Quantit√† aumentata e ultimo utilizzo annullato',
      nuovaQuantitaDisponibile: giacenza.quantitaDisponibile,
      utilizzoAnnullato: {
        id: ultimoUtilizzo._id,
        postazioneId: ultimoUtilizzo.postazioneId
      }
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// POST - Aggiungi prodotti direttamente alle giacenze operatore (per finalizzazione ordini/RDT)
app.post('/api/add-product-to-operator', authenticateToken, async (req, res) => {
  try {
    const { productId, quantitaAggiunta, assegnazioneId, note } = req.body;

    // Trova l'assegnazione per ottenere l'userId dell'operatore
    const assegnazione = await Assegnazione.findById(assegnazioneId).populate('userId');
    if (!assegnazione) {
      return res.status(404).json({ message: 'Assegnazione non trovata' });
    }

    const operatoreId = assegnazione.userId._id || assegnazione.userId;

    // Trova o crea giacenza per l'operatore
    let giacenza = await GiacenzaUtente.findOne({
      userId: operatoreId,
      productId,
      attiva: true
    });

    if (!giacenza) {
      // Crea nuova giacenza per l'operatore
      giacenza = new GiacenzaUtente({
        userId: operatoreId,
        productId,
        quantitaAssegnata: quantitaAggiunta,
        quantitaDisponibile: quantitaAggiunta,
        quantitaMinima: 0,
        assegnatoDa: req.user.userId,
        note: note || 'Aggiunto da finalizzazione ordine/RDT'
      });
    } else {
      // Aggiorna giacenza esistente
      giacenza.quantitaAssegnata += quantitaAggiunta;
      giacenza.quantitaDisponibile += quantitaAggiunta;
    }

    await giacenza.save();

    // Registra l'aggiunta
    const aggiunta = new Aggiunta({
      userId: operatoreId,
      productId,
      giacenzaUtenteId: giacenza._id,
      assegnazioneId,
      quantitaAggiunta,
      quantitaPrimaDellAggiunta: giacenza.quantitaDisponibile - quantitaAggiunta,
      quantitaDopoAggiunta: giacenza.quantitaDisponibile,
      motivo: 'FINALIZZAZIONE_ORDINE_RDT',
      note: note || 'Prodotti aggiunti da finalizzazione ordine/RDT'
    });

    await aggiunta.save();

    res.status(200).json({
      message: 'Prodotti aggiunti alle giacenze operatore',
      giacenza: {
        quantitaAssegnata: giacenza.quantitaAssegnata,
        quantitaDisponibile: giacenza.quantitaDisponibile
      }
    });
  } catch (error) {
    console.error('Errore aggiunta prodotti operatore:', error);
    res.status(500).json({ message: error.message });
  }
});

// SOSTITUISCI l'endpoint PUT /api/admin/utilizzi/:id nel tuo server.js con questo:

app.get('/api/admin/utilizzi', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { userId, settimanaId, startDate, endDate, productId, poloId, mezzoId } = req.query;
    
    const filter = {};
    if (userId) filter.userId = userId;
    if (settimanaId) filter.settimanaId = settimanaId;
    if (productId) filter.productId = productId;
    if (poloId) filter.poloId = poloId;
    if (mezzoId) filter.mezzoId = mezzoId;
    
    if (startDate && endDate) {
      filter.dataUtilizzo = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    }
    
    const utilizzi = await Utilizzo.find(filter)
      .populate('userId', 'username email')
      .populate('productId', 'nome codice unita categoria')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .populate('poloId', 'nome')
      .populate('mezzoId', 'nome')
      .populate('giacenzaUtenteId', 'quantitaDisponibile quantitaAssegnata quantitaMinima')
      .select('+note') // ‚Üê AGGIUNTO: include esplicitamente il campo note
      .sort({ dataUtilizzo: -1 });
    
    // Debug per verificare le note
    console.log('Primo utilizzo note:', utilizzi[0]?.note);
    
    res.json(utilizzi);
  } catch (error) {
    console.error('Errore get utilizzi:', error);
    res.status(500).json({ message: error.message });
  }
});

app.put('/api/admin/utilizzi/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { quantitaUtilizzata, note } = req.body;

    console.log('Dati ricevuti per modifica:', { id, quantitaUtilizzata, note }); // Debug

    // Trova l'utilizzo esistente
    const utilizzo = await Utilizzo.findById(id)
      .populate('giacenzaUtenteId')
      .populate('productId', 'nome unita');

    if (!utilizzo) {
      return res.status(404).json({ message: 'Utilizzo non trovato' });
    }

    // Calcola la differenza di quantit√†
    const quantitaPrecedente = utilizzo.quantitaUtilizzata;
    const nuovaQuantita = parseInt(quantitaUtilizzata);
    const differenza = nuovaQuantita - quantitaPrecedente;

    // Trova la giacenza associata
    const giacenza = utilizzo.giacenzaUtenteId;
    if (!giacenza) {
      return res.status(404).json({ message: 'Giacenza associata non trovata' });
    }

    // Verifica che la modifica non porti la giacenza sotto zero
    const nuovaQuantitaDisponibile = giacenza.quantitaDisponibile - differenza;
    if (nuovaQuantitaDisponibile < 0) {
      return res.status(400).json({ 
        message: `Impossibile modificare: la giacenza diventerebbe negativa (${nuovaQuantitaDisponibile})` 
      });
    }

    // Verifica che non si superi la quantit√† assegnata
    if (nuovaQuantitaDisponibile > giacenza.quantitaAssegnata) {
      return res.status(400).json({ 
        message: `Impossibile modificare: la quantit√† disponibile supererebbe quella assegnata` 
      });
    }

    // CORREZIONE: Aggiorna l'utilizzo con la nota
    utilizzo.quantitaUtilizzata = nuovaQuantita;
    utilizzo.note = note; // ‚Üê RIMOSSA la condizione || utilizzo.note
    utilizzo.quantitaRimasta = utilizzo.quantitaPrimaDellUso - nuovaQuantita;
    
    console.log('Salvando utilizzo con nota:', utilizzo.note); // Debug
    
    await utilizzo.save();

    // Aggiorna la giacenza
    giacenza.quantitaDisponibile = nuovaQuantitaDisponibile;
    await giacenza.save();

    // Restituisce l'utilizzo aggiornato con populate
    const utilizzoAggiornato = await Utilizzo.findById(id)
      .populate('userId', 'username email')
      .populate('productId', 'nome codice unita categoria')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .populate('poloId', 'nome')
      .populate('mezzoId', 'nome');

    console.log('Utilizzo aggiornato:', utilizzoAggiornato.note); // Debug

    res.json({
      message: 'Utilizzo modificato con successo',
      utilizzo: utilizzoAggiornato,
      giacenzaAggiornata: {
        quantitaDisponibile: giacenza.quantitaDisponibile,
        quantitaAssegnata: giacenza.quantitaAssegnata
      }
    });
  } catch (error) {
    console.error('Errore modifica utilizzo:', error);
    res.status(500).json({ message: error.message });
  }
});

// NUOVO: Elimina utilizzo e ripristina giacenza (Admin)
app.delete('/api/admin/utilizzi/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    // Trova l'utilizzo da eliminare
    const utilizzo = await Utilizzo.findById(id)
      .populate('giacenzaUtenteId')
      .populate('productId', 'nome unita')
      .populate('userId', 'username');

    if (!utilizzo) {
      return res.status(404).json({ message: 'Utilizzo non trovato' });
    }

    // Trova la giacenza associata
    const giacenza = utilizzo.giacenzaUtenteId;
    if (!giacenza) {
      return res.status(404).json({ message: 'Giacenza associata non trovata' });
    }

    // Ripristina la quantit√† nella giacenza
    const quantitaDaRipristinare = utilizzo.quantitaUtilizzata;
    const nuovaQuantitaDisponibile = giacenza.quantitaDisponibile + quantitaDaRipristinare;

    // Verifica che non si superi la quantit√† assegnata
    if (nuovaQuantitaDisponibile > giacenza.quantitaAssegnata) {
      return res.status(400).json({ 
        message: `Impossibile eliminare: la quantit√† ripristinata supererebbe quella assegnata` 
      });
    }

    // Aggiorna la giacenza
    giacenza.quantitaDisponibile = nuovaQuantitaDisponibile;
    await giacenza.save();

    // Salva info per il log prima di eliminare
    const logInfo = {
      prodotto: utilizzo.productId.nome,
      utente: utilizzo.userId.username,
      quantitaRipristinata: quantitaDaRipristinare,
      dataUtilizzo: utilizzo.dataUtilizzo
    };

    // Elimina l'utilizzo
    await Utilizzo.findByIdAndDelete(id);

    res.json({
      message: `Utilizzo eliminato e ripristinati ${quantitaDaRipristinare} ${utilizzo.productId.unita} di ${utilizzo.productId.nome}`,
      eliminato: logInfo,
      giacenzaAggiornata: {
        quantitaDisponibile: giacenza.quantitaDisponibile,
        quantitaAssegnata: giacenza.quantitaAssegnata
      }
    });
  } catch (error) {
    console.error('Errore eliminazione utilizzo:', error);
    res.status(500).json({ message: error.message });
  }
});



app.post('/api/admin/migrate-utilizzi-notes', authenticateToken, requireAdmin, async (req, res) => {
  try {
    // Aggiorna tutti gli utilizzi che non hanno il campo note
    const result = await Utilizzo.updateMany(
      { note: { $exists: false } },
      { $set: { note: '' } }
    );
    
    res.json({
      message: 'Migrazione completata',
      documentiAggiornati: result.modifiedCount
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// NUOVO: Endpoint per statistiche utilizzi (bonus)
app.get('/api/admin/utilizzi/stats', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { settimanaId, userId } = req.query;
    
    const matchFilter = {};
    if (settimanaId) matchFilter.settimanaId = new mongoose.Types.ObjectId(settimanaId);
    if (userId) matchFilter.userId = new mongoose.Types.ObjectId(userId);
    
    const stats = await Utilizzo.aggregate([
      { $match: matchFilter },
      {
        $group: {
          _id: {
            userId: '$userId',
            productId: '$productId'
          },
          totalUtilizzato: { $sum: '$quantitaUtilizzata' },
          numeroUtilizzi: { $sum: 1 },
          ultimoUtilizzo: { $max: '$dataUtilizzo' },
          primoUtilizzo: { $min: '$dataUtilizzo' }
        }
      },
      {
        $lookup: {
          from: 'users',
          localField: '_id.userId',
          foreignField: '_id',
          as: 'user'
        }
      },
      {
        $lookup: {
          from: 'products',
          localField: '_id.productId',
          foreignField: '_id',
          as: 'product'
        }
      },
      {
        $project: {
          utente: { $arrayElemAt: ['$user.username', 0] },
          prodotto: { $arrayElemAt: ['$product.nome', 0] },
          unita: { $arrayElemAt: ['$product.unita', 0] },
          totalUtilizzato: 1,
          numeroUtilizzi: 1,
          ultimoUtilizzo: 1,
          primoUtilizzo: 1
        }
      },
      { $sort: { totalUtilizzato: -1 } }
    ]);
    
    const totali = await Utilizzo.aggregate([
      { $match: matchFilter },
      {
        $group: {
          _id: null,
          totaleUtilizzi: { $sum: 1 },
          totaleQuantita: { $sum: '$quantitaUtilizzata' },
          utentiAttivi: { $addToSet: '$userId' },
          prodottiUtilizzati: { $addToSet: '$productId' }
        }
      },
      {
        $project: {
          totaleUtilizzi: 1,
          totaleQuantita: 1,
          numeroUtentiAttivi: { $size: '$utentiAttivi' },
          numeroProdottiUtilizzati: { $size: '$prodottiUtilizzati' }
        }
      }
    ]);
    
    res.json({
      dettagli: stats,
      totali: totali[0] || {
        totaleUtilizzi: 0,
        totaleQuantita: 0,
        numeroUtentiAttivi: 0,
        numeroProdottiUtilizzati: 0
      }
    });
  } catch (error) {
    console.error('Errore statistiche utilizzi:', error);
    res.status(500).json({ message: error.message });
  }

});// MODIFICATA: Usa prodotto con supporto multi-settimana
app.post('/api/use-product', authenticateToken, async (req, res) => {
  try {
    const { productId, quantitaUtilizzata, assegnazioneId, postazioneId } = req.body;
    
    // Verifica assegnazione
    const assegnazione = await Assegnazione.findOne({
      _id: assegnazioneId,
      userId: req.user.userId,
      attiva: true
    });

    if (!assegnazione) {
      return res.status(403).json({ message: 'Assegnazione non valida' });
    }

    // Cerca prima giacenza specifica per settimana, poi globale
    let giacenza = await GiacenzaUtente.findOne({
      userId: req.user.userId,
      productId,
      settimanaId: assegnazione.settimanaId,
      attiva: true
    });

    // Se non trova giacenza specifica, cerca globale
    if (!giacenza) {
      giacenza = await GiacenzaUtente.findOne({
        userId: req.user.userId,
        productId,
        isGlobale: true,
        attiva: true
      });
    }

    if (!giacenza) {
      return res.status(404).json({ message: 'Prodotto non assegnato a questo utente' });
    }

    if (giacenza.quantitaDisponibile < quantitaUtilizzata) {
      return res.status(400).json({ 
        message: `Quantit√† insufficiente. Disponibile: ${giacenza.quantitaDisponibile}` 
      });
    }

    // Salva stato prima dell'uso
    const quantitaPrecedente = giacenza.quantitaDisponibile;

    // Crea utilizzo
    const utilizzo = new Utilizzo({
      userId: req.user.userId,
      productId,
      giacenzaUtenteId: giacenza._id,
      assegnazioneId,
      quantitaUtilizzata,
      quantitaPrimaDellUso: quantitaPrecedente,
      quantitaRimasta: quantitaPrecedente - quantitaUtilizzata,
      settimanaId: assegnazione.settimanaId,
      poloId: assegnazione.poloId,
      mezzoId: assegnazione.mezzoId,
      postazioneId: postazioneId || null
    });

    await utilizzo.save();

    // Aggiorna giacenza
    giacenza.quantitaDisponibile -= quantitaUtilizzata;

    await giacenza.save();

    res.status(201).json({
      utilizzo,
      nuovaQuantitaDisponibile: giacenza.quantitaDisponibile,
      sottoSoglia: giacenza.quantitaDisponibile <= giacenza.quantitaMinima
    });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

// Routes Admin per gestire giacenze
// AGGIORNA anche l'endpoint admin /api/admin/giacenze per coerenza:

// app.get('/api/admin/giacenze', authenticateToken, requireAdmin, async (req, res) => {
//   try {
//     const { 
//       userId, 
//       settimanaId,
//       productId,
//       stato,
//       searchTerm,
//       quantitaAssegnataMin,
//       quantitaAssegnataMax,
//       quantitaDisponibileMin,
//       quantitaDisponibileMax,
//       sogliaMinimaMin,
//       sogliaMinimaMax
//     } = req.query;
    
//     let filter = { attiva: true };
    
//     // Filtri base
//     if (userId) filter.userId = userId;
//     if (productId) filter.productId = productId;
    
//     if (settimanaId) {
//       filter.$or = [
//         { settimanaId: settimanaId },
//         { isGlobale: true }
//       ];
//     }

//     console.log('üîç Admin filtri:', filter);

//     const giacenze = await GiacenzaUtente.find(filter)
//       .populate('userId', 'username email')
//       .populate('productId', 'nome codice categoria unita descrizione')
//       .populate('assegnatoDa', 'username')
//       .populate('settimanaId', 'numero anno dataInizio dataFine')
//       .sort({ 'userId.username': 1, 'productId.nome': 1 });

//     let filteredGiacenze = giacenze;

//     // Applica filtri aggiuntivi
//     if (stato) {
//       if (stato === 'critico') {
//         filteredGiacenze = filteredGiacenze.filter(g => 
//           g.quantitaDisponibile <= g.quantitaMinima
//         );
//       } else if (stato === 'ok') {
//         filteredGiacenze = filteredGiacenze.filter(g => 
//           g.quantitaDisponibile > g.quantitaMinima
//         );
//       }
//     }

//     if (searchTerm) {
//       const term = searchTerm.toLowerCase();
//       filteredGiacenze = filteredGiacenze.filter(g => 
//         g.userId?.username.toLowerCase().includes(term) ||
//         g.userId?.email.toLowerCase().includes(term) ||
//         g.productId?.nome.toLowerCase().includes(term) ||
//         g.productId?.categoria.toLowerCase().includes(term) ||
//         g.assegnatoDa?.username.toLowerCase().includes(term)
//       );
//     }

//     // Filtri numerici (stessa logica dell'endpoint utente)
//     if (quantitaAssegnataMin) {
//       filteredGiacenze = filteredGiacenze.filter(g => 
//         g.quantitaAssegnata >= parseInt(quantitaAssegnataMin)
//       );
//     }
    
//     if (quantitaAssegnataMax) {
//       filteredGiacenze = filteredGiacenze.filter(g => 
//         g.quantitaAssegnata <= parseInt(quantitaAssegnataMax)
//       );
//     }

//     if (quantitaDisponibileMin) {
//       filteredGiacenze = filteredGiacenze.filter(g => 
//         g.quantitaDisponibile >= parseInt(quantitaDisponibileMin)
//       );
//     }
    
//     if (quantitaDisponibileMax) {
//       filteredGiacenze = filteredGiacenze.filter(g => 
//         g.quantitaDisponibile <= parseInt(quantitaDisponibileMax)
//       );
//     }

//     if (sogliaMinimaMin) {
//       filteredGiacenze = filteredGiacenze.filter(g => 
//         g.quantitaMinima >= parseInt(sogliaMinimaMin)
//       );
//     }
    
//     if (sogliaMinimaMax) {
//       filteredGiacenze = filteredGiacenze.filter(g => 
//         g.quantitaMinima <= parseInt(sogliaMinimaMax)
//       );
//     }

//     console.log(`üìä Admin risultati: ${filteredGiacenze.length} di ${giacenze.length} giacenze`);

//     res.json(filteredGiacenze);
//   } catch (error) {
//     console.error('‚ùå Errore caricamento giacenze admin:', error);
//     res.status(500).json({ message: error.message });
//   }
// });
app.get('/api/admin/giacenze', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { 
      userId, 
      settimanaId,
      productId,
      stato,
      searchTerm,
      quantitaAssegnataMin,
      quantitaAssegnataMax,
      quantitaDisponibileMin,
      quantitaDisponibileMax,
      sogliaMinimaMin,
      sogliaMinimaMax
    } = req.query;
    
    console.log('üîç Parametri ricevuti:', req.query);
    
    let filter = { attiva: true };
    
    // ‚úÖ FILTRI BASE
    if (productId) filter.productId = productId;
    
    // ‚úÖ FILTRO CORRETTO: giacenze globali solo dell'operatore specifico
    if (userId) {
      // Se √® specificato un operatore, mostra solo le sue giacenze (globali e non)
      filter.userId = userId;
    } else if (settimanaId) {
      // Se √® specificata solo una settimana, mostra giacenze di quella settimana + giacenze globali
      filter.$or = [
        { settimanaId: settimanaId, isGlobale: { $ne: true } },
        { isGlobale: true }
      ];
    } else {
      // Se nessun filtro specifico, mostra tutte le giacenze
      // Nessun filtro aggiuntivo necessario
    }

    console.log('üîç Filtro MongoDB:', filter);

    // ‚úÖ CARICA GIACENZE con populate
    const giacenze = await GiacenzaUtente.find(filter)
      .populate('userId', 'username email')
      .populate('productId', 'nome codice categoria unita descrizione')
      .populate('assegnatoDa', 'username')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .sort({ 'userId.username': 1, 'productId.nome': 1 });

    let filteredGiacenze = giacenze;
    console.log(`üì¶ Giacenze caricate: ${giacenze.length}`);

    // ‚úÖ FILTRO STATO (post-query)
    if (stato) {
      const beforeCount = filteredGiacenze.length;
      if (stato === 'critico') {
        filteredGiacenze = filteredGiacenze.filter(g => 
          g.quantitaDisponibile <= g.quantitaMinima
        );
      } else if (stato === 'ok') {
        filteredGiacenze = filteredGiacenze.filter(g => 
          g.quantitaDisponibile > g.quantitaMinima
        );
      }
      console.log(`üéØ Filtro stato "${stato}": ${beforeCount} -> ${filteredGiacenze.length}`);
    }

    // ‚úÖ FILTRO RICERCA (post-query)
    if (searchTerm) {
      const beforeCount = filteredGiacenze.length;
      const term = searchTerm.toLowerCase();
      filteredGiacenze = filteredGiacenze.filter(g => 
        g.userId?.username.toLowerCase().includes(term) ||
        g.userId?.email.toLowerCase().includes(term) ||
        g.productId?.nome.toLowerCase().includes(term) ||
        g.productId?.categoria.toLowerCase().includes(term) ||
        g.assegnatoDa?.username.toLowerCase().includes(term)
      );
      console.log(`üîç Filtro ricerca "${searchTerm}": ${beforeCount} -> ${filteredGiacenze.length}`);
    }

    // ‚úÖ FILTRI NUMERICI (con validazione)
    if (quantitaAssegnataMin && !isNaN(quantitaAssegnataMin)) {
      const beforeCount = filteredGiacenze.length;
      filteredGiacenze = filteredGiacenze.filter(g => 
        g.quantitaAssegnata >= parseInt(quantitaAssegnataMin)
      );
      console.log(`üìä Filtro quantit√† assegnata min ${quantitaAssegnataMin}: ${beforeCount} -> ${filteredGiacenze.length}`);
    }
    
    if (quantitaAssegnataMax && !isNaN(quantitaAssegnataMax)) {
      const beforeCount = filteredGiacenze.length;
      filteredGiacenze = filteredGiacenze.filter(g => 
        g.quantitaAssegnata <= parseInt(quantitaAssegnataMax)
      );
      console.log(`üìä Filtro quantit√† assegnata max ${quantitaAssegnataMax}: ${beforeCount} -> ${filteredGiacenze.length}`);
    }

    if (quantitaDisponibileMin && !isNaN(quantitaDisponibileMin)) {
      const beforeCount = filteredGiacenze.length;
      filteredGiacenze = filteredGiacenze.filter(g => 
        g.quantitaDisponibile >= parseInt(quantitaDisponibileMin)
      );
      console.log(`üìä Filtro quantit√† disponibile min ${quantitaDisponibileMin}: ${beforeCount} -> ${filteredGiacenze.length}`);
    }
    
    if (quantitaDisponibileMax && !isNaN(quantitaDisponibileMax)) {
      const beforeCount = filteredGiacenze.length;
      filteredGiacenze = filteredGiacenze.filter(g => 
        g.quantitaDisponibile <= parseInt(quantitaDisponibileMax)
      );
      console.log(`üìä Filtro quantit√† disponibile max ${quantitaDisponibileMax}: ${beforeCount} -> ${filteredGiacenze.length}`);
    }

    if (sogliaMinimaMin && !isNaN(sogliaMinimaMin)) {
      const beforeCount = filteredGiacenze.length;
      filteredGiacenze = filteredGiacenze.filter(g => 
        g.quantitaMinima >= parseInt(sogliaMinimaMin)
      );
      console.log(`üìä Filtro soglia minima min ${sogliaMinimaMin}: ${beforeCount} -> ${filteredGiacenze.length}`);
    }
    
    if (sogliaMinimaMax && !isNaN(sogliaMinimaMax)) {
      const beforeCount = filteredGiacenze.length;
      filteredGiacenze = filteredGiacenze.filter(g => 
        g.quantitaMinima <= parseInt(sogliaMinimaMax)
      );
      console.log(`üìä Filtro soglia minima max ${sogliaMinimaMax}: ${beforeCount} -> ${filteredGiacenze.length}`);
    }

    console.log(`‚úÖ Risultati finali: ${filteredGiacenze.length} di ${giacenze.length} giacenze`);

    res.json(filteredGiacenze);
  } catch (error) {
    console.error('‚ùå Errore caricamento giacenze admin:', error);
    res.status(500).json({ message: error.message });
  }
});

// MODIFICATA: Assegna/Aggiorna giacenza con supporto multi-settimana
app.post('/api/admin/assign-giacenza', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { 
      userId, 
      productId, 
      quantitaAssegnata, 
      quantitaMinima, 
      note,
      aggiungiAlla = false,
      settimanaId = null, // Opzionale: se specificato, crea giacenza per settimana specifica
      applicaATutteLeSettimane = false // Se true, applica a tutte le settimane assegnate
    } = req.body;

    let giacenzeCreate = [];
    
    if (applicaATutteLeSettimane) {
      // Trova tutte le assegnazioni dell'utente
      const assegnazioni = await Assegnazione.find({ 
        userId, 
        attiva: true 
      }).distinct('settimanaId');
      
      // Crea/aggiorna giacenza per ogni settimana
      for (const settId of assegnazioni) {
        const result = await createOrUpdateGiacenza({
          userId,
          productId,
          quantitaAssegnata,
          quantitaMinima,
          note,
          aggiungiAlla,
          settimanaId: settId,
          isGlobale: false,
          assegnatoDa: req.user.userId
        });
        giacenzeCreate.push(result);
      }
    } else if (settimanaId) {
      // Crea giacenza per settimana specifica
      const result = await createOrUpdateGiacenza({
        userId,
        productId,
        quantitaAssegnata,
        quantitaMinima,
        note,
        aggiungiAlla,
        settimanaId,
        isGlobale: false,
        assegnatoDa: req.user.userId
      });
      giacenzeCreate.push(result);
    } else {
      // Crea giacenza globale
      const result = await createOrUpdateGiacenza({
        userId,
        productId,
        quantitaAssegnata,
        quantitaMinima,
        note,
        aggiungiAlla,
        isGlobale: true,
        assegnatoDa: req.user.userId
      });
      giacenzeCreate.push(result);
    }

    res.status(201).json(giacenzeCreate.length === 1 ? giacenzeCreate[0] : giacenzeCreate);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

// Funzione helper per creare/aggiornare giacenza
async function createOrUpdateGiacenza(data) {
  const {
    userId,
    productId,
    quantitaAssegnata,
    quantitaMinima,
    note,
    aggiungiAlla,
    settimanaId,
    isGlobale,
    assegnatoDa
  } = data;

  // Verifica se esiste gi√†
  let filter = { userId, productId, attiva: true };
  if (settimanaId) {
    filter.settimanaId = settimanaId;
  } else {
    filter.isGlobale = true;
  }

  let giacenza = await GiacenzaUtente.findOne(filter);

  if (giacenza) {
    // Aggiorna esistente
    const quantitaPrecedente = giacenza.quantitaDisponibile;
    
    if (aggiungiAlla) {
      giacenza.quantitaDisponibile += parseInt(quantitaAssegnata);
      giacenza.quantitaAssegnata += parseInt(quantitaAssegnata);
    } else {
      giacenza.quantitaDisponibile = parseInt(quantitaAssegnata);
      giacenza.quantitaAssegnata = parseInt(quantitaAssegnata);
    }
    
    giacenza.quantitaMinima = parseInt(quantitaMinima) || 0;
    giacenza.note = note;
    giacenza.dataAssegnazione = new Date();
    giacenza.assegnatoDa = assegnatoDa;

    await giacenza.save();

    // Registra ricarica se √® un'aggiunta
    if (aggiungiAlla) {
      const ricarica = new RicaricaGiacenza({
        giacenzaUtenteId: giacenza._id,
        userId,
        productId,
        quantitaPrecedente,
        quantitaAggiunta: parseInt(quantitaAssegnata),
        quantitaNuova: giacenza.quantitaDisponibile,
        motivazione: note || 'Ricarica da admin',
        eseguitoDa: assegnatoDa
      });
      await ricarica.save();
    }
  } else {
    // Crea nuova giacenza
    giacenza = new GiacenzaUtente({
      userId,
      productId,
      settimanaId,
      quantitaAssegnata: parseInt(quantitaAssegnata),
      quantitaDisponibile: parseInt(quantitaAssegnata),
      quantitaMinima: parseInt(quantitaMinima) || 0,
      note,
      assegnatoDa,
      isGlobale: isGlobale || false
    });
    await giacenza.save();
  }

  const populated = await GiacenzaUtente.findById(giacenza._id)
    .populate('userId', 'username')
    .populate('productId', 'nome unita')
    .populate('assegnatoDa', 'username')
    .populate('settimanaId', 'numero anno');

  return populated;
}

// PUT - Aggiorna giacenza esistente (Admin)
app.put('/api/admin/giacenze/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { 
      quantitaAssegnata, 
      quantitaDisponibile, 
      quantitaMinima, 
      note, 
      attiva = true 
    } = req.body;

    console.log('üîÑ [BACKEND] Richiesta aggiornamento giacenza:', {
      id,
      quantitaAssegnata,
      quantitaDisponibile, 
      quantitaMinima,
      note,
      attiva
    });

    const giacenza = await GiacenzaUtente.findById(id);
    if (!giacenza) {
      return res.status(404).json({ message: 'Giacenza non trovata' });
    }

    // Registra la modifica se c'√® un cambio di quantit√†
    const quantitaPrecedente = giacenza.quantitaDisponibile;
    
    // Registra valori prima della modifica
    const valoriPrecedenti = {
      quantitaAssegnata: giacenza.quantitaAssegnata,
      quantitaDisponibile: giacenza.quantitaDisponibile,
      quantitaMinima: giacenza.quantitaMinima
    };

    // Aggiorna i campi
    if (quantitaAssegnata !== undefined) giacenza.quantitaAssegnata = parseInt(quantitaAssegnata);
    if (quantitaDisponibile !== undefined) giacenza.quantitaDisponibile = parseInt(quantitaDisponibile);
    if (quantitaMinima !== undefined) giacenza.quantitaMinima = parseInt(quantitaMinima);
    if (note !== undefined) giacenza.note = note;
    giacenza.attiva = attiva;
    giacenza.dataModifica = new Date();

    console.log('üîÑ [BACKEND] Valori prima del salvataggio:', valoriPrecedenti);
    console.log('üîÑ [BACKEND] Valori dopo aggiornamento:', {
      quantitaAssegnata: giacenza.quantitaAssegnata,
      quantitaDisponibile: giacenza.quantitaDisponibile,
      quantitaMinima: giacenza.quantitaMinima
    });

    await giacenza.save();
    console.log('‚úÖ [BACKEND] Giacenza salvata con successo');

    // Registra la modifica nella storia se c'√® stato un cambio di quantit√†
    if (quantitaDisponibile !== undefined && quantitaPrecedente !== parseInt(quantitaDisponibile)) {
      const ricarica = new RicaricaGiacenza({
        giacenzaUtenteId: giacenza._id,
        userId: giacenza.userId,
        productId: giacenza.productId,
        quantitaPrecedente,
        quantitaAggiunta: parseInt(quantitaDisponibile) - quantitaPrecedente,
        quantitaNuova: parseInt(quantitaDisponibile),
        motivazione: note || 'Modifica da admin',
        eseguitoDa: req.user.userId
      });
      await ricarica.save();
    }

    // Ritorna la giacenza aggiornata con populate
    const updatedGiacenza = await GiacenzaUtente.findById(giacenza._id)
      .populate('userId', 'username email')
      .populate('productId', 'nome codice categoria unita')
      .populate('assegnatoDa', 'username')
      .populate('settimanaId', 'numero anno dataInizio dataFine');

    console.log('üì§ [BACKEND] Risposta finale - quantit√† minima:', updatedGiacenza.quantitaMinima);
    
    res.json(updatedGiacenza);
  } catch (error) {
    console.error('‚ùå Errore aggiornamento giacenza:', error);
    res.status(400).json({ message: error.message });
  }
});

// DELETE - Elimina giacenza (Admin)
app.delete('/api/admin/giacenze/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    const giacenza = await GiacenzaUtente.findById(id);
    if (!giacenza) {
      return res.status(404).json({ message: 'Giacenza non trovata' });
    }

    // Verifica se ci sono utilizzi associati a questa giacenza
    const utilizziCount = await Utilizzo.countDocuments({ giacenzaUtenteId: id });
    if (utilizziCount > 0) {
      return res.status(400).json({ 
        message: `Impossibile eliminare: ci sono ${utilizziCount} utilizzi associati a questa giacenza. Elimina prima gli utilizzi o disattiva la giacenza.`
      });
    }

    // Elimina anche le ricariche associate
    await RicaricaGiacenza.deleteMany({ giacenzaUtenteId: id });

    // Elimina la giacenza
    await GiacenzaUtente.findByIdAndDelete(id);

    res.json({ 
      message: 'Giacenza eliminata con successo',
      deletedId: id
    });
  } catch (error) {
    console.error('‚ùå Errore eliminazione giacenza:', error);
    res.status(400).json({ message: error.message });
  }
});

// Utilizzi Routes
app.get('/api/utilizzi/my', authenticateToken, async (req, res) => {
  try {
    const { settimanaId, postazioneId } = req.query;
    const filter = { userId: req.user.userId };
    
    if (settimanaId) filter.settimanaId = settimanaId;
    if (postazioneId && postazioneId !== 'all') filter.postazioneId = postazioneId;
    
    console.log('üîç Filtro utilizzi:', filter);
    
    const utilizzi = await Utilizzo.find(filter)
      .populate('productId', 'nome codice unita categoria')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .populate('poloId', 'nome')
      .populate('mezzoId', 'nome')
      .populate('postazioneId', 'nome indirizzo')
      .sort({ createdAt: -1 });
    
    console.log(`üìä Trovati ${utilizzi.length} utilizzi`);
    res.json(utilizzi);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Admin - Tutti gli utilizzi
app.get('/api/admin/utilizzi', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { userId, settimanaId, startDate, endDate } = req.query;
    
    const filter = {};
    if (userId) filter.userId = userId;
    if (settimanaId) filter.settimanaId = settimanaId;
    if (startDate && endDate) {
      filter.dataUtilizzo = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    }
    
    const utilizzi = await Utilizzo.find(filter)
      .populate('userId', 'username')
      .populate('productId', 'nome codice unita categoria')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .populate('poloId', 'nome')
      .populate('mezzoId', 'nome')
      .sort({ dataUtilizzo: -1 });
    
    res.json(utilizzi);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// // Report Excel

app.get('/api/reports/excel', authenticateToken, async (req, res) => {
  try {
    const { settimanaId, poloId, mezzoId, userId, postazioneId } = req.query;
    
    const filter = {};
    if (settimanaId) filter.settimanaId = settimanaId;
    if (poloId) filter.poloId = poloId;
    if (mezzoId) filter.mezzoId = mezzoId;
    if (postazioneId) filter.postazioneId = postazioneId;
    
    // Se non √® admin, pu√≤ vedere solo i suoi utilizzi
    if (req.user.role !== 'admin') {
      filter.userId = req.user.userId;
    } else if (userId) {
      filter.userId = userId;
    }
    
    const utilizzi = await Utilizzo.find(filter)
      .populate('userId', 'username email')
      .populate('productId', 'nome codice categoria unita')
      .populate('giacenzaUtenteId')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .populate('poloId', 'nome')
      .populate('mezzoId', 'nome')
      .populate('postazioneId', 'nome');
    
    // Aggrega dati per report UTILIZZI (foglio 1)
    const reportData = {};

    utilizzi.forEach(utilizzo => {
      // Aggiungi postazioneId alla chiave per raggruppare per postazione
      const postazioneKey = utilizzo.postazioneId?._id || 'no-postazione';
      const key = `${utilizzo.userId._id}-${utilizzo.productId._id}-${utilizzo.settimanaId?._id || 'global'}-${postazioneKey}`;

      if (!reportData[key]) {
        let periodoSettimana = 'Non disponibile';
        if (utilizzo.settimanaId?.dataInizio && utilizzo.settimanaId?.dataFine) {
          const dataInizio = new Date(utilizzo.settimanaId.dataInizio);
          const dataFine = new Date(utilizzo.settimanaId.dataFine);
          periodoSettimana = `${dataInizio.toLocaleDateString('it-IT')} - ${dataFine.toLocaleDateString('it-IT')}`;
        }

        const quantitaDisponibile = utilizzo.giacenzaUtenteId?.quantitaDisponibile || 0;
        const quantitaMinima = utilizzo.giacenzaUtenteId?.quantitaMinima || 0;
        const quantitaAssegnata = utilizzo.giacenzaUtenteId?.quantitaAssegnata || 0;

        let quantitaDaOrdinare = 0;
        if (quantitaDisponibile <= quantitaMinima) {
          quantitaDaOrdinare = quantitaAssegnata - quantitaDisponibile;
        }

        reportData[key] = {
          'Utente': utilizzo.userId.username,
          'Prodotto': utilizzo.productId.nome,
          'Categoria': utilizzo.productId.categoria || 'N/A',
          'Quantit√† Totale Utilizzata': 0,
          'Unit√†': utilizzo.productId.unita,
          'Quantit√† Disponibile': quantitaDisponibile,
          'Quantit√† Assegnata': quantitaAssegnata,
          'Quantit√† Minima': quantitaMinima,
          'Quantit√† da Ordinare': quantitaDaOrdinare,
          'Polo': utilizzo.poloId?.nome || 'N/A',
          'Mezzo': utilizzo.mezzoId?.nome || 'N/A',
          'Postazione': utilizzo.postazioneId?.nome || 'N/A',
          'Periodo': periodoSettimana
        };
      }

      reportData[key]['Quantit√† Totale Utilizzata'] += utilizzo.quantitaUtilizzata;
    });
    
    // Converti in array e calcola stato per UTILIZZI
    const dataArray = Object.values(reportData).map(item => {
      const disponibile = item['Quantit√† Disponibile'];
      const minima = item['Quantit√† Minima'];
      const assegnata = item['Quantit√† Assegnata'];
      
      let quantitaDaOrdinare = 0;
      if (disponibile <= minima && assegnata > 0) {
        quantitaDaOrdinare = assegnata - disponibile;
      }
      
      return {
        ...item,
        'Quantit√† da Ordinare': quantitaDaOrdinare,
        'Da Ordinare': (disponibile <= minima) ? 'S√å' : 'NO',
        'Stato Giacenza': disponibile <= minima ? 'CRITICO' : 'OK',
        'Percentuale Rimasta': assegnata > 0 ? Math.round((disponibile / assegnata) * 100) + '%' : '0%'
      };
    });
    
    // Ordina per prodotti critici prima, poi per quantit√† da ordinare (decrescente)
    dataArray.sort((a, b) => {
      if (a['Da Ordinare'] === 'S√å' && b['Da Ordinare'] === 'NO') return -1;
      if (a['Da Ordinare'] === 'NO' && b['Da Ordinare'] === 'S√å') return 1;
      
      if (a['Da Ordinare'] === 'S√å' && b['Da Ordinare'] === 'S√å') {
        return b['Quantit√† da Ordinare'] - a['Quantit√† da Ordinare'];
      }
      
      return a['Utente'].localeCompare(b['Utente']) || a['Prodotto'].localeCompare(b['Prodotto']);
    });

    // ========== NUOVO: Query per GIACENZE PER OPERATORE (foglio 3) ==========
    
    // Costruisci filtro per giacenze
    const giacenzeFilter = {};
    if (settimanaId) {
      giacenzeFilter.$or = [
        { settimanaId: settimanaId },
        { settimanaId: null }
      ];
    }
    
    // Se non √® admin, pu√≤ vedere solo le sue giacenze
    if (req.user.role !== 'admin') {
      giacenzeFilter.userId = req.user.userId;
    } else if (userId) {
      giacenzeFilter.userId = userId;
    }
    
    // Query per tutte le giacenze (SEMPLIFICATA)
    const giacenze = await GiacenzaUtente.find(giacenzeFilter)
      .populate('userId', 'username email')
      .populate('productId', 'nome codice categoria unita')
      .populate('settimanaId', 'numero anno dataInizio dataFine');

    // Query separata per le assegnazioni
    let assegnazioniMap = {};
    if (giacenze.length > 0) {
      // Costruisci filtro per assegnazioni
      const assegnazioniFilter = {
        userId: { $in: giacenze.map(g => g.userId._id) }
      };
      if (settimanaId) assegnazioniFilter.settimanaId = settimanaId;
      if (poloId) assegnazioniFilter.poloId = poloId;
      if (mezzoId) assegnazioniFilter.mezzoId = mezzoId;
      
      const assegnazioni = await Assegnazione.find(assegnazioniFilter)
        .populate('poloId', 'nome')
        .populate('mezzoId', 'nome')
        .populate('postazioneId', 'nome')
        .populate('settimanaId', 'numero anno');
      
      // Crea mappa per lookup veloce
      assegnazioni.forEach(ass => {
        const key = `${ass.userId}-${ass.settimanaId?._id || 'global'}`;
        if (!assegnazioniMap[key]) {
          assegnazioniMap[key] = ass;
        }
      });
      
      // Crea anche una mappa per utente (per giacenze globali)
      assegnazioni.forEach(ass => {
        const userKey = `${ass.userId}-user`;
        if (!assegnazioniMap[userKey]) {
          assegnazioniMap[userKey] = ass;
        }
      });
    }
    
    // NUOVO: Endpoint per statistiche giacenze utente (bonus)
app.get('/api/my-giacenze/stats', authenticateToken, async (req, res) => {
  try {
    const { settimanaId } = req.query;
    
    let filter = { 
      userId: req.user.userId, 
      attiva: true 
    };
    
    if (settimanaId) {
      filter.$or = [
        { settimanaId: settimanaId },
        { isGlobale: true }
      ];
    }
    
    const giacenze = await GiacenzaUtente.find(filter)
      .populate('productId', 'categoria');
    
    // Calcola statistiche
    const stats = {
      totaleGiacenze: giacenze.length,
      giacenzeCritiche: giacenze.filter(g => g.quantitaDisponibile <= g.quantitaMinima).length,
      giacenzeOk: giacenze.filter(g => g.quantitaDisponibile > g.quantitaMinima).length,
      quantitaTotaleAssegnata: giacenze.reduce((sum, g) => sum + g.quantitaAssegnata, 0),
      quantitaTotaleDisponibile: giacenze.reduce((sum, g) => sum + g.quantitaDisponibile, 0),
      categorieUniche: [...new Set(giacenze.map(g => g.productId?.categoria).filter(Boolean))],
      percentualeTotaleRimasta: 0
    };
    
    // Calcola percentuale totale rimasta
    if (stats.quantitaTotaleAssegnata > 0) {
      stats.percentualeTotaleRimasta = Math.round(
        (stats.quantitaTotaleDisponibile / stats.quantitaTotaleAssegnata) * 100
      );
    }
    
    // Statistiche per categoria
    const statsByCategory = {};
    stats.categorieUniche.forEach(categoria => {
      const giacenzeCategoria = giacenze.filter(g => g.productId?.categoria === categoria);
      statsByCategory[categoria] = {
        totale: giacenzeCategoria.length,
        critiche: giacenzeCategoria.filter(g => g.quantitaDisponibile <= g.quantitaMinima).length,
        quantitaAssegnata: giacenzeCategoria.reduce((sum, g) => sum + g.quantitaAssegnata, 0),
        quantitaDisponibile: giacenzeCategoria.reduce((sum, g) => sum + g.quantitaDisponibile, 0)
      };
    });
    
    res.json({
      ...stats,
      perCategoria: statsByCategory
    });
  } catch (error) {
    console.error('‚ùå Errore statistiche giacenze:', error);
    res.status(500).json({ message: error.message });
  }
});
    // Prepara dati per foglio GIACENZE PER OPERATORE
    const giacenzeData = giacenze.map(giacenza => {
      const settimanaKey = giacenza.settimanaId?._id || 'global';
      const userKey = `${giacenza.userId._id}-user`;
      
      // Cerca prima per settimana specifica, poi per utente generico
      const assegnazione = assegnazioniMap[`${giacenza.userId._id}-${settimanaKey}`] || 
                          assegnazioniMap[userKey];
      
      let periodoSettimana = 'Globale';
      if (giacenza.settimanaId?.dataInizio && giacenza.settimanaId?.dataFine) {
        const dataInizio = new Date(giacenza.settimanaId.dataInizio);
        const dataFine = new Date(giacenza.settimanaId.dataFine);
        periodoSettimana = `Sett. ${giacenza.settimanaId.numero}/${giacenza.settimanaId.anno} (${dataInizio.toLocaleDateString('it-IT')} - ${dataFine.toLocaleDateString('it-IT')})`;
      }
      
      const stato = giacenza.quantitaDisponibile <= giacenza.quantitaMinima ? 'CRITICO' : 'OK';
      const percentuale = giacenza.quantitaAssegnata > 0 
        ? Math.round((giacenza.quantitaDisponibile / giacenza.quantitaAssegnata) * 100) 
        : 0;
      
      return {
        'Operatore': giacenza.userId.username,
        'Email': giacenza.userId.email || 'N/A',
        'Prodotto': giacenza.productId.nome,
        'Categoria': giacenza.productId.categoria || 'N/A',
        'Unit√†': giacenza.productId.unita,
        'Quantit√† Assegnata': giacenza.quantitaAssegnata,
        'Quantit√† Disponibile': giacenza.quantitaDisponibile,
        'Soglia Minima': giacenza.quantitaMinima,
        'Stato': stato,
        'Percentuale Rimasta': percentuale + '%',
        'Settimana/Periodo': periodoSettimana,
        'Ultima Modifica': giacenza.updatedAt ? new Date(giacenza.updatedAt).toLocaleDateString('it-IT') : 'N/A'
      };
    });
    
    // Ordina giacenze: prima quelle critiche, poi per operatore
    giacenzeData.sort((a, b) => {
      if (a.Stato === 'CRITICO' && b.Stato === 'OK') return -1;
      if (a.Stato === 'OK' && b.Stato === 'CRITICO') return 1;
      return a.Operatore.localeCompare(b.Operatore) || a.Prodotto.localeCompare(b.Prodotto);
    });

    // ========== CREAZIONE FILE EXCEL CON 3 FOGLI ==========
    
    const wb = xlsx.utils.book_new();
    
    // FOGLIO 1: Report Utilizzi (esistente)
    const ws = xlsx.utils.json_to_sheet(dataArray);
    ws['!cols'] = [
      { wch: 15 }, { wch: 25 }, { wch: 15 }, { wch: 12 }, { wch: 8 },
      { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 15 }, { wch: 15 },
      { wch: 15 }, { wch: 20 }, { wch: 12 }, { wch: 12 }, { wch: 12 }
    ];
    
    // Formattazione condizionale per le righe critiche (foglio 1)
    if (ws['!ref']) {
      const range = xlsx.utils.decode_range(ws['!ref']);
      for (let row = 1; row <= range.e.r; row++) {
        const daOrdinareCell = ws[xlsx.utils.encode_cell({ r: row, c: 12 })];
        if (daOrdinareCell && daOrdinareCell.v === 'S√å') {
          for (let col = 0; col <= range.e.c; col++) {
            const cellRef = xlsx.utils.encode_cell({ r: row, c: col });
            if (!ws[cellRef]) ws[cellRef] = {};
            ws[cellRef].s = {
              fill: { fgColor: { rgb: "FFE6E6" } },
              font: { bold: true }
            };
          }
        }
      }
    }
    
    xlsx.utils.book_append_sheet(wb, ws, 'Report Utilizzi');
    
    // FOGLIO 2: Lista Ordini - Aggregazione separata per evitare righe duplicate
    const ordiniData = {};
    
    // Aggrega per userId + productId (ignora settimana e postazione per evitare duplicati)
    utilizzi.forEach(utilizzo => {
      const ordineKey = `${utilizzo.userId._id}-${utilizzo.productId._id}`;
      
      if (!ordiniData[ordineKey]) {
        const quantitaDisponibile = utilizzo.giacenzaUtenteId?.quantitaDisponibile || 0;
        const quantitaMinima = utilizzo.giacenzaUtenteId?.quantitaMinima || 0;
        const quantitaAssegnata = utilizzo.giacenzaUtenteId?.quantitaAssegnata || 0;
        
        // Solo se √® sotto soglia
        if (quantitaDisponibile <= quantitaMinima) {
          const quantitaDaOrdinare = quantitaAssegnata > quantitaDisponibile ? 
            quantitaAssegnata - quantitaDisponibile : 0;
            
          ordiniData[ordineKey] = {
            'Prodotto': utilizzo.productId.nome,
            'Categoria': utilizzo.productId.categoria || 'N/A',
            'Utente': utilizzo.userId.username,
            'Quantit√† da Ordinare': quantitaDaOrdinare,
            'Quantit√† Assegnata': quantitaAssegnata,
            'Unit√†': utilizzo.productId.unita,
            'Disponibile': quantitaDisponibile,
            'Minima': quantitaMinima,
            'Note': `Sotto soglia - Urgente`
          };
        }
      }
    });
    
    const riepilogoOrdini = Object.values(ordiniData);
    
    if (riepilogoOrdini.length > 0) {
      const wsOrdini = xlsx.utils.json_to_sheet(riepilogoOrdini);
      wsOrdini['!cols'] = [
        { wch: 25 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 },
        { wch: 8 }, { wch: 12 }, { wch: 12 }, { wch: 20 }
      ];
      xlsx.utils.book_append_sheet(wb, wsOrdini, 'Lista Ordini');
    }
    
    // FOGLIO 3: Giacenze per Operatore (NUOVO)
    if (giacenzeData.length > 0) {
      const wsGiacenze = xlsx.utils.json_to_sheet(giacenzeData);
      wsGiacenze['!cols'] = [
        { wch: 18 }, { wch: 25 }, { wch: 30 }, { wch: 15 }, { wch: 8 },
        { wch: 15 }, { wch: 18 }, { wch: 12 }, { wch: 10 }, { wch: 12 },
        { wch: 25 }, { wch: 12 }
      ];
      
      // Formattazione condizionale per giacenze critiche
      if (wsGiacenze['!ref']) {
        const rangeGiacenze = xlsx.utils.decode_range(wsGiacenze['!ref']);
        for (let row = 1; row <= rangeGiacenze.e.r; row++) {
          const statoCell = wsGiacenze[xlsx.utils.encode_cell({ r: row, c: 8 })];
          if (statoCell && statoCell.v === 'CRITICO') {
            for (let col = 0; col <= rangeGiacenze.e.c; col++) {
              const cellRef = xlsx.utils.encode_cell({ r: row, c: col });
              if (!wsGiacenze[cellRef]) wsGiacenze[cellRef] = {};
              wsGiacenze[cellRef].s = {
                fill: { fgColor: { rgb: "FFCCCC" } },
                font: { bold: true }
              };
            }
          }
        }
      }
      
      xlsx.utils.book_append_sheet(wb, wsGiacenze, 'Giacenze per Operatore');
    }
    
    const buffer = xlsx.write(wb, { type: 'buffer', bookType: 'xlsx' });
    
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename=report_completo_giacenze_${Date.now()}.xlsx`);
    res.send(buffer);
    
  } catch (error) {
    console.error('‚ùå Errore generazione report:', error);
    res.status(500).json({ message: error.message });
  }
});

// Route rimanenti
app.get('/api/poli', authenticateToken, async (req, res) => {
  try {
    const poli = await Polo.find({ attivo: true });
    res.json(poli);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// POST - Crea nuovo polo (Admin)
app.post('/api/poli', authenticateToken, async (req, res) => {
  try {
    const { nome, descrizione, indirizzo, coordinate } = req.body;
    
    if (!nome) {
      return res.status(400).json({ message: 'Il nome del polo √® obbligatorio' });
    }

    // Verifica se esiste gi√† un polo con lo stesso nome
    const existingPolo = await Polo.findOne({ nome: nome.trim(), attivo: true });
    if (existingPolo) {
      return res.status(400).json({ message: 'Esiste gi√† un polo con questo nome' });
    }

    const newPolo = new Polo({
      nome: nome.trim(),
      descrizione: descrizione?.trim() || '',
      indirizzo: indirizzo?.trim() || '',
      coordinate: coordinate || { lat: '', lng: '' },
      attivo: true
    });

    const savedPolo = await newPolo.save();
    res.status(201).json(savedPolo);
  } catch (error) {
    console.error('‚ùå Errore creazione polo:', error);
    res.status(500).json({ message: error.message });
  }
});

// PUT - Aggiorna polo (Admin)
app.put('/api/poli/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { nome, descrizione, indirizzo, coordinate } = req.body;
    
    if (!nome) {
      return res.status(400).json({ message: 'Il nome del polo √® obbligatorio' });
    }

    // Verifica se esiste gi√† un altro polo con lo stesso nome
    const existingPolo = await Polo.findOne({ 
      nome: nome.trim(), 
      attivo: true,
      _id: { $ne: id }
    });
    if (existingPolo) {
      return res.status(400).json({ message: 'Esiste gi√† un polo con questo nome' });
    }

    const updatedPolo = await Polo.findByIdAndUpdate(
      id,
      {
        nome: nome.trim(),
        descrizione: descrizione?.trim() || '',
        indirizzo: indirizzo?.trim() || '',
        coordinate: coordinate || { lat: '', lng: '' }
      },
      { new: true, runValidators: true }
    );

    if (!updatedPolo) {
      return res.status(404).json({ message: 'Polo non trovato' });
    }

    res.json(updatedPolo);
  } catch (error) {
    console.error('‚ùå Errore aggiornamento polo:', error);
    res.status(500).json({ message: error.message });
  }
});

// DELETE - Elimina polo (Admin) - Con controlli per assegnazioni e utilizzi
app.delete('/api/poli/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Verifica se il polo esiste
    const polo = await Polo.findById(id);
    if (!polo) {
      return res.status(404).json({ message: 'Polo non trovato' });
    }

    // Controlla se ci sono assegnazioni attive collegate al polo
    const assegnazioniAttive = await Assegnazione.find({ 
      poloId: id, 
      attiva: true 
    }).populate('userId', 'username');

    // Controlla se ci sono utilizzi collegati al polo
    const utilizzi = await Utilizzo.find({ poloId: id }).limit(1);

    // Controlla se ci sono postazioni collegate al polo
    const postazioni = await Postazione.find({ poloId: id, attiva: true });

    if (assegnazioniAttive.length > 0 || utilizzi.length > 0 || postazioni.length > 0) {
      const conflitti = [];
      
      if (assegnazioniAttive.length > 0) {
        conflitti.push(`${assegnazioniAttive.length} assegnazioni attive (operatori: ${assegnazioniAttive.map(a => a.userId.username).join(', ')})`);
      }
      
      if (utilizzi.length > 0) {
        const countUtilizzi = await Utilizzo.countDocuments({ poloId: id });
        conflitti.push(`${countUtilizzi} utilizzi registrati`);
      }
      
      if (postazioni.length > 0) {
        conflitti.push(`${postazioni.length} postazioni collegate`);
      }

      return res.status(400).json({ 
        message: 'Impossibile eliminare il polo',
        dettagli: `Il polo "${polo.nome}" ha ancora:`,
        conflitti,
        richiediConferma: true,
        poloId: id,
        nomeCompleto: polo.nome
      });
    }

    // Se non ci sono conflitti, procedi con l'eliminazione (soft delete)
    await Polo.findByIdAndUpdate(id, { attivo: false });
    
    res.json({ 
      message: 'Polo eliminato con successo',
      nome: polo.nome
    });
  } catch (error) {
    console.error('‚ùå Errore eliminazione polo:', error);
    res.status(500).json({ message: error.message });
  }
});

// DELETE - Forza eliminazione polo (Admin) - Con parametro force
app.delete('/api/poli/:id/force', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    const polo = await Polo.findById(id);
    if (!polo) {
      return res.status(404).json({ message: 'Polo non trovato' });
    }

    // Elimina/disattiva tutti i dati collegati
    await Promise.all([
      // Disattiva assegnazioni
      Assegnazione.updateMany({ poloId: id }, { attiva: false }),
      // Disattiva postazioni
      Postazione.updateMany({ poloId: id }, { attiva: false }),
      // Note: gli utilizzi rimangono per storico ma il polo risulter√† non pi√π attivo
    ]);

    // Elimina il polo
    await Polo.findByIdAndUpdate(id, { attivo: false });
    
    res.json({ 
      message: 'Polo e tutti i dati collegati eliminati con successo',
      nome: polo.nome
    });
  } catch (error) {
    console.error('‚ùå Errore eliminazione forzata polo:', error);
    res.status(500).json({ message: error.message });
  }
});

// ‚úÖ ROTTE API PER MEZZI
app.get('/api/mezzi', authenticateToken, async (req, res) => {
  try {
    const mezzi = await Mezzo.find({ attivo: true });
    res.json(mezzi);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// POST - Crea nuovo mezzo
app.post('/api/mezzi', authenticateToken, async (req, res) => {
  try {
    const { nome, targa, tipo, marca, modello, descrizione } = req.body;
    
    if (!nome) {
      return res.status(400).json({ message: 'Nome mezzo √® obbligatorio' });
    }

    const nuovoMezzo = new Mezzo({
      nome: nome.trim(),
      targa: targa?.trim() || '',
      tipo: tipo?.trim() || '',
      marca: marca?.trim() || '',
      modello: modello?.trim() || '',
      descrizione: descrizione?.trim() || ''
    });

    const mezzoSalvato = await nuovoMezzo.save();
    console.log('‚úÖ Mezzo creato:', mezzoSalvato);
    res.status(201).json(mezzoSalvato);
  } catch (error) {
    console.error('‚ùå Errore creazione mezzo:', error);
    if (error.code === 11000) {
      res.status(400).json({ message: 'Esiste gi√† un mezzo con questo nome' });
    } else {
      res.status(500).json({ message: error.message });
    }
  }
});

// PUT - Aggiorna mezzo esistente
app.put('/api/mezzi/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { nome, targa, tipo, marca, modello, descrizione } = req.body;

    if (!nome) {
      return res.status(400).json({ message: 'Nome mezzo √® obbligatorio' });
    }

    const mezzoAggiornato = await Mezzo.findByIdAndUpdate(
      id,
      {
        nome: nome.trim(),
        targa: targa?.trim() || '',
        tipo: tipo?.trim() || '',
        marca: marca?.trim() || '',
        modello: modello?.trim() || '',
        descrizione: descrizione?.trim() || ''
      },
      { new: true, runValidators: true }
    );

    if (!mezzoAggiornato) {
      return res.status(404).json({ message: 'Mezzo non trovato' });
    }

    console.log('‚úÖ Mezzo aggiornato:', mezzoAggiornato);
    res.json(mezzoAggiornato);
  } catch (error) {
    console.error('‚ùå Errore aggiornamento mezzo:', error);
    if (error.code === 11000) {
      res.status(400).json({ message: 'Esiste gi√† un mezzo con questo nome' });
    } else {
      res.status(500).json({ message: error.message });
    }
  }
});

// DELETE - Elimina mezzo (soft delete)
app.delete('/api/mezzi/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    // Verifica se il mezzo √® utilizzato in assegnazioni attive
    const assegnazioniAttive = await Assegnazione.countDocuments({
      mezzoId: id,
      attiva: true
    });

    if (assegnazioniAttive > 0) {
      return res.status(400).json({
        richiediConferma: true,
        conflitti: [`Il mezzo √® utilizzato in ${assegnazioniAttive} assegnazioni attive`],
        dettagli: `Il mezzo ha ${assegnazioniAttive} assegnazioni attive. Eliminandolo verranno disattivate tutte le assegnazioni collegate.`
      });
    }

    // Soft delete del mezzo
    const mezzoEliminato = await Mezzo.findByIdAndUpdate(
      id,
      { attivo: false },
      { new: true }
    );

    if (!mezzoEliminato) {
      return res.status(404).json({ message: 'Mezzo non trovato' });
    }

    console.log('‚úÖ Mezzo eliminato (soft delete):', mezzoEliminato.nome);
    res.json({ message: 'Mezzo eliminato con successo' });
  } catch (error) {
    console.error('‚ùå Errore eliminazione mezzo:', error);
    res.status(500).json({ message: error.message });
  }
});

// DELETE - Eliminazione forzata mezzo
app.delete('/api/mezzi/:id/force', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    // Disattiva tutte le assegnazioni collegate
    await Assegnazione.updateMany(
      { mezzoId: id, attiva: true },
      { attiva: false }
    );

    // Soft delete del mezzo
    const mezzoEliminato = await Mezzo.findByIdAndUpdate(
      id,
      { attivo: false },
      { new: true }
    );

    if (!mezzoEliminato) {
      return res.status(404).json({ message: 'Mezzo non trovato' });
    }

    console.log('‚úÖ Mezzo eliminato forzatamente:', mezzoEliminato.nome);
    console.log('‚úÖ Disattivate assegnazioni collegate al mezzo');
    res.json({ message: 'Mezzo e assegnazioni collegate eliminate con successo' });
  } catch (error) {
    console.error('‚ùå Errore eliminazione forzata mezzo:', error);
    res.status(500).json({ message: error.message });
  }
});

app.get('/api/settimane', authenticateToken, async (req, res) => {
  try {
    const settimane = await Settimana.find().sort({ anno: -1, numero: -1 });
    res.json(settimane);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// ‚úÖ ROTTE API AGGIORNATE per gestire campi Ordine e RDT

// GET - Lista assegnazioni con filtri aggiornati
app.get('/api/assegnazioni', authenticateToken, async (req, res) => {
  try {
    const { 
      userId, 
      poloId, 
      mezzoId, 
      settimanaId, 
      attiva,
      ordine,    // ‚úÖ NUOVO FILTRO
      rdt        // ‚úÖ NUOVO FILTRO
    } = req.query;
    
    const filter = {};
    
    // Filtri standard
    if (userId) filter.userId = userId;
    if (poloId) filter.poloId = poloId;
    if (mezzoId) filter.mezzoId = mezzoId;
    if (settimanaId) filter.settimanaId = settimanaId;
    
    // ‚úÖ NUOVI FILTRI per Ordine e RDT
    if (ordine) filter.ordine = { $regex: ordine, $options: 'i' };
    if (rdt) filter.rdt = { $regex: rdt, $options: 'i' };
    
    // Filtro stato
    if (attiva === 'true') {
      filter.attiva = true;
    } else if (attiva === 'false') {
      filter.attiva = false;
    }
    
    console.log('üìã Filter applicato:', filter);
    
    const assegnazioni = await Assegnazione.find(filter)
      .populate('userId', 'username email')
      .populate('poloId', 'nome')
      .populate('mezzoId', 'nome')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .populate('postazioneId', 'nome')
      .populate('ordine', 'numero cliente dataConsegna priorita stato')
      .populate('rdt', 'numero cliente dataConsegna priorita stato')
      .sort({ createdAt: -1 });
    
    console.log(`üìä Risultati trovati: ${assegnazioni.length}`);
    
    res.json(assegnazioni);
  } catch (error) {
    console.error('‚ùå Errore query assegnazioni:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Crea nuova assegnazione con campi aggiornati
app.post('/api/assegnazioni', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { 
      userId, 
      poloId, 
      settimanaId, 
      mezzoId, 
      postazioneId,
      ordine,    // ‚úÖ NUOVO CAMPO
      rdt        // ‚úÖ NUOVO CAMPO
    } = req.body;

    // Validazioni esistenti
    const existingUserAssignment = await Assegnazione.findOne({
      userId, settimanaId, attiva: true
    });
    if (existingUserAssignment) {
      return res.status(400).json({ message: 'Operatore gi√† assegnato per questa settimana' });
    }

    const existingPoloAssignments = await Assegnazione.find({
      poloId, settimanaId, attiva: true
    });
    if (existingPoloAssignments.length >= 2) {
      return res.status(400).json({ message: 'Polo al completo (max 2 operatori)' });
    }

    // ‚úÖ VALIDAZIONE OPZIONALE: Controllo unicit√† ordine (se fornito)
    if (ordine && ordine.trim()) {
      const existingOrdine = await Assegnazione.findOne({
        ordine: ordine.trim(),
        attiva: true
      });
      if (existingOrdine) {
        return res.status(400).json({ 
          message: `Ordine "${ordine}" gi√† assegnato ad un altro operatore`,
          conflictType: 'ORDINE_ALREADY_ASSIGNED'
        });
      }
    }

    // ‚úÖ VALIDAZIONE OPZIONALE: Controllo unicit√† RDT (se fornito)
    if (rdt && rdt.trim()) {
      const existingRdt = await Assegnazione.findOne({
        rdt: rdt.trim(),
        attiva: true
      });
      if (existingRdt) {
        return res.status(400).json({ 
          message: `RDT "${rdt}" gi√† assegnato ad un altro operatore`,
          conflictType: 'RDT_ALREADY_ASSIGNED'
        });
      }
    }

    // Informazioni per mezzi condivisi
    let sharedVehicleInfo = null;
    if (existingPoloAssignments.length === 1) {
      const existingMezzo = existingPoloAssignments[0].mezzoId;
      if (existingMezzo.toString() === mezzoId) {
        sharedVehicleInfo = {
          shared: true,
          sharedWith: existingPoloAssignments[0].userId.username,
          vehicleName: (await Mezzo.findById(mezzoId)).nome
        };
      }
    }

    // ‚úÖ CREA ASSEGNAZIONE con nuovi campi
    const assegnazione = new Assegnazione({
      userId,
      poloId,
      mezzoId,
      settimanaId,
      postazioneId,
      ordine: ordine?.trim() || null,  // ‚úÖ NUOVO CAMPO
      rdt: rdt?.trim() || null,        // ‚úÖ NUOVO CAMPO
      createdBy: req.user.userId
    });
    
    await assegnazione.save();
    
    const populated = await Assegnazione.findById(assegnazione._id)
      .populate('userId', 'username email')
      .populate('poloId', 'nome')
      .populate('mezzoId', 'nome')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .populate('postazioneId', 'nome');
    
    res.status(201).json({
      message: 'Assegnazione creata con successo',
      assegnazione: populated,
      sharedVehicleInfo
    });
  } catch (error) {
    console.error('Errore creazione assegnazione:', error);
    res.status(400).json({ message: error.message });
  }
});

// PUT - Modifica assegnazione con nuovi campi
app.put('/api/assegnazioni/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { 
      userId, 
      poloId, 
      settimanaId, 
      mezzoId, 
      postazioneId,
      ordine,    // ‚úÖ NUOVO CAMPO
      rdt        // ‚úÖ NUOVO CAMPO
    } = req.body;

    // Trova l'assegnazione esistente
    const existingAssegnazione = await Assegnazione.findById(id);
    if (!existingAssegnazione) {
      return res.status(404).json({ message: 'Assegnazione non trovata' });
    }

    // ‚úÖ VALIDAZIONI per nuovi campi se cambiano
    
    // Controllo unicit√† ordine (se diverso da quello attuale)
    if (ordine && ordine.trim() && ordine.trim() !== existingAssegnazione.ordine) {
      const conflictOrdine = await Assegnazione.findOne({
        _id: { $ne: id },
        ordine: ordine.trim(),
        attiva: true
      });
      if (conflictOrdine) {
        return res.status(400).json({ 
          message: `Ordine "${ordine}" gi√† assegnato ad un altro operatore`,
          conflictType: 'ORDINE_ALREADY_ASSIGNED'
        });
      }
    }

    // Controllo unicit√† RDT (se diverso da quello attuale)
    if (rdt && rdt.trim() && rdt.trim() !== existingAssegnazione.rdt) {
      const conflictRdt = await Assegnazione.findOne({
        _id: { $ne: id },
        rdt: rdt.trim(),
        attiva: true
      });
      if (conflictRdt) {
        return res.status(400).json({ 
          message: `RDT "${rdt}" gi√† assegnato ad un altro operatore`,
          conflictType: 'RDT_ALREADY_ASSIGNED'
        });
      }
    }

    // Validazioni esistenti per operatore, polo, mezzo...
    if (existingAssegnazione.userId.toString() !== userId) {
      const conflictUserAssignment = await Assegnazione.findOne({
        _id: { $ne: id },
        userId,
        settimanaId,
        attiva: true
      });

      if (conflictUserAssignment) {
        const conflict = await Assegnazione.findById(conflictUserAssignment._id)
          .populate('poloId', 'nome')
          .populate('mezzoId', 'nome');
        
        return res.status(400).json({ 
          message: `Operatore gi√† assegnato per questa settimana al ${conflict.poloId?.nome} con ${conflict.mezzoId?.nome}`,
          conflictType: 'USER_ALREADY_ASSIGNED'
        });
      }
    }

    // ‚úÖ AGGIORNA con tutti i campi inclusi i nuovi
    const updateData = {
      userId,
      poloId,
      mezzoId,
      settimanaId,
      postazioneId,
      ordine: ordine?.trim() || null,  // ‚úÖ NUOVO CAMPO
      rdt: rdt?.trim() || null         // ‚úÖ NUOVO CAMPO
    };

    const updated = await Assegnazione.findByIdAndUpdate(
      id,
      updateData,
      { new: true }
    )
    .populate('userId', 'username email')
    .populate('poloId', 'nome')
    .populate('mezzoId', 'nome')
    .populate('settimanaId', 'numero anno dataInizio dataFine')
    .populate('postazioneId', 'nome');

    res.json({
      message: 'Assegnazione modificata con successo',
      assegnazione: updated
    });
    
  } catch (error) {
    console.error('Errore modifica assegnazione:', error);
    res.status(400).json({ 
      message: 'Errore nella modifica dell\'assegnazione: ' + error.message 
    });
  }
});

// ‚úÖ NUOVO ENDPOINT: Ricerca per Ordine
app.get('/api/assegnazioni/search/ordine/:ordine', authenticateToken, async (req, res) => {
  try {
    const { ordine } = req.params;
    
    const assegnazioni = await Assegnazione.find({
      ordine: { $regex: ordine, $options: 'i' },
      attiva: true
    })
    .populate('userId', 'username email')
    .populate('poloId', 'nome')
    .populate('mezzoId', 'nome')
    .populate('settimanaId', 'numero anno dataInizio dataFine')
    .populate('postazioneId', 'nome');

    res.json({
      ordine,
      assegnazioni,
      totale: assegnazioni.length
    });
  } catch (error) {
    console.error('Errore ricerca ordine:', error);
    res.status(500).json({ message: error.message });
  }
});

// ‚úÖ NUOVO ENDPOINT: Ricerca per RDT
app.get('/api/assegnazioni/search/rdt/:rdt', authenticateToken, async (req, res) => {
  try {
    const { rdt } = req.params;
    
    const assegnazioni = await Assegnazione.find({
      rdt: { $regex: rdt, $options: 'i' },
      attiva: true
    })
    .populate('userId', 'username email')
    .populate('poloId', 'nome')
    .populate('mezzoId', 'nome')
    .populate('settimanaId', 'numero anno dataInizio dataFine')
    .populate('postazioneId', 'nome');

    res.json({
      rdt,
      assegnazioni,
      totale: assegnazioni.length
    });
  } catch (error) {
    console.error('Errore ricerca RDT:', error);
    res.status(500).json({ message: error.message });
  }
});

// ‚úÖ ENDPOINT per statistiche aggiornato con nuovi campi
app.get('/api/assegnazioni/stats', authenticateToken, async (req, res) => {
  try {
    const { settimanaId } = req.query;
    
    const filter = { attiva: true };
    if (settimanaId) filter.settimanaId = settimanaId;
    
    const assegnazioni = await Assegnazione.find(filter);
    
    // Raggruppa per polo/settimana per calcolare occupazione
    const occupazione = {};
    assegnazioni.forEach(a => {
      const key = `${a.poloId}-${a.settimanaId}`;
      occupazione[key] = (occupazione[key] || 0) + 1;
    });
    
    // ‚úÖ NUOVE STATISTICHE per Ordine e RDT
    const ordiniAssegnati = assegnazioni.filter(a => a.ordine && typeof a.ordine === 'string' && a.ordine.trim()).length;
    const rdtAssegnati = assegnazioni.filter(a => a.rdt && typeof a.rdt === 'string' && a.rdt.trim()).length;
    
    const stats = {
      totaleAssegnazioni: assegnazioni.length,
      operatoriAttivi: new Set(assegnazioni.map(a => a.userId.toString())).size,
      poliOccupati: new Set(assegnazioni.map(a => a.poloId.toString())).size,
      mezziInUso: new Set(assegnazioni.map(a => a.mezzoId.toString())).size,
      poliCompleti: Object.values(occupazione).filter(count => count >= 2).length,
      poliParziali: Object.values(occupazione).filter(count => count === 1).length,
      mediaOperatoriPerPolo: assegnazioni.length > 0 ? 
        (assegnazioni.length / new Set(assegnazioni.map(a => `${a.poloId}-${a.settimanaId}`)).size).toFixed(1) : 0,
      // ‚úÖ NUOVE STATISTICHE
      ordiniAssegnati,
      rdtAssegnati,
      percentualeOrdini: assegnazioni.length > 0 ? Math.round((ordiniAssegnati / assegnazioni.length) * 100) : 0,
      percentualeRdt: assegnazioni.length > 0 ? Math.round((rdtAssegnati / assegnazioni.length) * 100) : 0
    };
    
    res.json(stats);
  } catch (error) {
    console.error('Errore statistiche assegnazioni:', error);
    res.status(500).json({ message: error.message });
  }
});

// 
// 27 luglio
// app.get('/api/assegnazioni', authenticateToken, async (req, res) => {
//   try {
//     const { 
//       userId, 
//       poloId, 
//       mezzoId, 
//       settimanaId, 
//       attiva // pu√≤ essere: 'true', 'false', o undefined
//     } = req.query;
    
//     const filter = {};
    
//     // Filtri standard
//     if (userId) filter.userId = userId;
//     if (poloId) filter.poloId = poloId;
//     if (mezzoId) filter.mezzoId = mezzoId;
//     if (settimanaId) filter.settimanaId = settimanaId;
    
//     // CORREZIONE: Filtro stato solo se specificato esplicitamente
//     if (attiva === 'true') {
//       filter.attiva = true;
//       console.log('üü¢ Filtro: Solo ATTIVE');
//     } else if (attiva === 'false') {
//       filter.attiva = false;
//       console.log('üî¥ Filtro: Solo INATTIVE');
//     } else {
//       // attiva √® undefined - mostra TUTTO
//       console.log('üîµ Filtro: TUTTE (attive + inattive)');
//     }
    
//     console.log('üìã Filter applicato:', filter);
    
//     const assegnazioni = await Assegnazione.find(filter)
//       .populate('userId', 'username email')
//       .populate('poloId', 'nome')
//       .populate('mezzoId', 'nome')
//       .populate('settimanaId', 'numero anno dataInizio dataFine')
//       .sort({ createdAt: -1 });
    
//     console.log(`üìä Risultati trovati: ${assegnazioni.length}`);
    
//     res.json(assegnazioni);
//   } catch (error) {
//     console.error('‚ùå Errore query assegnazioni:', error);
//     res.status(500).json({ message: error.message });
//   }
// });

app.get('/api/assegnazioni/my', authenticateToken, async (req, res) => {
  try {
    const assegnazioni = await Assegnazione.find({ 
      userId: req.user.userId, 
      attiva: true 
    })
      .populate('poloId', 'nome')
      .populate('mezzoId', 'nome')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .sort({ 'settimanaId.anno': -1, 'settimanaId.numero': -1 });
    res.json(assegnazioni);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// // POST - Crea nuova assegnazione (con validazioni multi-operatore)
// app.post('/api/assegnazioni', authenticateToken, requireAdmin, async (req, res) => {
//   try {
//     const { userId, poloId, settimanaId, mezzoId } = req.body;

//     // 1. Controlli esistenti (operatore unico per settimana, max 2 per polo)
//     const existingUserAssignment = await Assegnazione.findOne({
//       userId, settimanaId, attiva: true
//     });
//     if (existingUserAssignment) {
//       return res.status(400).json({ message: 'Operatore gi√† assegnato per questa settimana' });
//     }

//     const existingPoloAssignments = await Assegnazione.find({
//       poloId, settimanaId, attiva: true
//     });
//     if (existingPoloAssignments.length >= 2) {
//       return res.status(400).json({ message: 'Polo al completo (max 2 operatori)' });
//     }

//     // ‚úÖ NUOVO: Informazioni per mezzi condivisi
//     let sharedVehicleInfo = null;
//     if (existingPoloAssignments.length === 1) {
//       const existingMezzo = existingPoloAssignments[0].mezzoId;
//       if (existingMezzo.toString() === mezzoId) {
//         sharedVehicleInfo = {
//           shared: true,
//           sharedWith: existingPoloAssignments[0].userId.username,
//           vehicleName: (await Mezzo.findById(mezzoId)).nome
//         };
//       }
//     }

//     // Crea assegnazione
//     const assegnazione = new Assegnazione(req.body);
//     await assegnazione.save();
    
//     const populated = await Assegnazione.findById(assegnazione._id)
//       .populate('userId', 'username email')
//       .populate('poloId', 'nome')
//       .populate('mezzoId', 'nome')
//       .populate('settimanaId', 'numero anno dataInizio dataFine');
    
//     res.status(201).json({
//       assegnazione: populated,
//       sharedVehicleInfo // Include info condivisione nella risposta
//     });
//   } catch (error) {
//     res.status(400).json({ message: error.message });
//   }
// });

// // PUT - Modifica assegnazione esistente (con validazioni)
// app.put('/api/assegnazioni/:id', authenticateToken, requireAdmin, async (req, res) => {
//   try {
//     const { id } = req.params;
//     const { userId, poloId, settimanaId, mezzoId } = req.body;

//     // Trova l'assegnazione esistente
//     const existingAssegnazione = await Assegnazione.findById(id);
//     if (!existingAssegnazione) {
//       return res.status(404).json({ message: 'Assegnazione non trovata' });
//     }

//     // Se i dati non sono cambiati, procedi senza validazioni
//     const isUnchanged = 
//       existingAssegnazione.userId.toString() === userId &&
//       existingAssegnazione.poloId.toString() === poloId &&
//       existingAssegnazione.settimanaId.toString() === settimanaId &&
//       existingAssegnazione.mezzoId.toString() === mezzoId;

//     if (isUnchanged) {
//       // Aggiorna solo altri campi (es. postazione, note)
//       const updated = await Assegnazione.findByIdAndUpdate(
//         id,
//         req.body,
//         { new: true }
//       )
//       .populate('userId', 'username email')
//       .populate('poloId', 'nome descrizione')
//       .populate('mezzoId', 'nome descrizione')
//       .populate('settimanaId', 'numero anno dataInizio dataFine')
//       .populate('postazioneId', 'nome descrizione');

//       return res.json({
//         message: 'Assegnazione aggiornata con successo',
//         assegnazione: updated
//       });
//     }

//     // ‚úÖ VALIDAZIONE 1: Se cambia l'operatore, controlla che il nuovo operatore non sia gi√† assegnato
//     if (existingAssegnazione.userId.toString() !== userId) {
//       const conflictUserAssignment = await Assegnazione.findOne({
//         _id: { $ne: id }, // Escludi l'assegnazione corrente
//         userId,
//         settimanaId,
//         attiva: true
//       });

//       if (conflictUserAssignment) {
//         const conflict = await Assegnazione.findById(conflictUserAssignment._id)
//           .populate('poloId', 'nome')
//           .populate('mezzoId', 'nome');
        
//         return res.status(400).json({ 
//           message: `Operatore gi√† assegnato per questa settimana al ${conflict.poloId?.nome} con ${conflict.mezzoId?.nome}`,
//           conflictType: 'USER_ALREADY_ASSIGNED'
//         });
//       }
//     }

//     // ‚úÖ VALIDAZIONE 2: Se cambia polo/settimana, controlla limite di 2 operatori
//     if (existingAssegnazione.poloId.toString() !== poloId || 
//         existingAssegnazione.settimanaId.toString() !== settimanaId) {
      
//       const existingPoloAssignments = await Assegnazione.find({
//         _id: { $ne: id }, // Escludi l'assegnazione corrente
//         poloId,
//         settimanaId,
//         attiva: true
//       });

//       if (existingPoloAssignments.length >= 2) {
//         const assignments = await Assegnazione.find({
//           _id: { $ne: id },
//           poloId,
//           settimanaId,
//           attiva: true
//         }).populate('userId', 'username').populate('mezzoId', 'nome');

//         return res.status(400).json({ 
//           message: 'Polo gi√† al completo per questa settimana (massimo 2 operatori)',
//           conflictType: 'POLO_FULL',
//           currentAssignments: assignments.map(a => ({
//             operatore: a.userId?.username,
//             mezzo: a.mezzoId?.nome
//           }))
//         });
//       }
//     }

//     // ‚úÖ VALIDAZIONE 3: Se cambia il mezzo, controlla che non sia gi√† assegnato
//     if (existingAssegnazione.mezzoId.toString() !== mezzoId) {
//       const conflictMezzoAssignment = await Assegnazione.findOne({
//         _id: { $ne: id }, // Escludi l'assegnazione corrente
//         mezzoId,
//         settimanaId,
//         attiva: true
//       });

//       if (conflictMezzoAssignment) {
//         const conflict = await Assegnazione.findById(conflictMezzoAssignment._id)
//           .populate('userId', 'username')
//           .populate('poloId', 'nome');
        
//         return res.status(400).json({ 
//           message: `Mezzo gi√† assegnato nella settimana a ${conflict.userId?.username} per il ${conflict.poloId?.nome}`,
//           conflictType: 'MEZZO_ALREADY_ASSIGNED'
//         });
//       }
//     }

//     // Se tutte le validazioni passano, aggiorna l'assegnazione
//     const updated = await Assegnazione.findByIdAndUpdate(
//       id,
//       req.body,
//       { new: true }
//     )
//     .populate('userId', 'username email')
//     .populate('poloId', 'nome descrizione')
//     .populate('mezzoId', 'nome descrizione')
//     .populate('settimanaId', 'numero anno dataInizio dataFine')
//     .populate('postazioneId', 'nome descrizione');

//     // Calcola informazioni sul polo aggiornato
//     const currentPoloAssignments = await Assegnazione.find({
//       poloId: updated.poloId._id,
//       settimanaId: updated.settimanaId._id,
//       attiva: true
//     });

//     res.json({
//       message: 'Assegnazione modificata con successo',
//       assegnazione: updated,
//       poloInfo: {
//         postiOccupati: currentPoloAssignments.length,
//         postiRimasti: 2 - currentPoloAssignments.length,
//         postiTotali: 2
//       }
//     });
    
//   } catch (error) {
//     console.error('Errore modifica assegnazione:', error);
    
//     if (error.code === 11000) {
//       return res.status(400).json({ 
//         message: 'Conflitto: questa combinazione esiste gi√†',
//         conflictType: 'DUPLICATE_ASSIGNMENT'
//       });
//     }
    
//     res.status(400).json({ 
//       message: 'Errore nella modifica dell\'assegnazione: ' + error.message 
//     });
//   }
// });

// ‚úÖ BONUS: Endpoint per ottenere informazioni sui posti disponibili
app.get('/api/assegnazioni/availability/:poloId/:settimanaId', authenticateToken, async (req, res) => {
  try {
    const { poloId, settimanaId } = req.params;
    
    const existingAssignments = await Assegnazione.find({
      poloId,
      settimanaId,
      attiva: true
    })
    .populate('userId', 'username')
    .populate('mezzoId', 'nome');

    const availability = {
      postiTotali: 2,
      postiOccupati: existingAssignments.length,
      postiRimasti: 2 - existingAssignments.length,
      isCompleto: existingAssignments.length >= 2,
      assegnazioniAttuali: existingAssignments.map(a => ({
        id: a._id,
        operatore: a.userId?.username,
        mezzo: a.mezzoId?.nome
      }))
    };

    res.json(availability);
  } catch (error) {
    console.error('Errore controllo disponibilit√†:', error);
    res.status(500).json({ message: error.message });
  }
});

// ‚úÖ BONUS: Endpoint per ottenere statistiche generali
app.get('/api/assegnazioni/stats', authenticateToken, async (req, res) => {
  try {
    const { settimanaId } = req.query;
    
    const filter = { attiva: true };
    if (settimanaId) filter.settimanaId = settimanaId;
    
    const assegnazioni = await Assegnazione.find(filter);
    
    // Raggruppa per polo/settimana per calcolare occupazione
    const occupazione = {};
    assegnazioni.forEach(a => {
      const key = `${a.poloId}-${a.settimanaId}`;
      occupazione[key] = (occupazione[key] || 0) + 1;
    });
    
    const stats = {
      totaleAssegnazioni: assegnazioni.length,
      operatoriAttivi: new Set(assegnazioni.map(a => a.userId.toString())).size,
      poliOccupati: new Set(assegnazioni.map(a => a.poloId.toString())).size,
      mezziInUso: new Set(assegnazioni.map(a => a.mezzoId.toString())).size,
      poliCompleti: Object.values(occupazione).filter(count => count >= 2).length,
      poliParziali: Object.values(occupazione).filter(count => count === 1).length,
      mediaOperatoriPerPolo: assegnazioni.length > 0 ? 
        (assegnazioni.length / new Set(assegnazioni.map(a => `${a.poloId}-${a.settimanaId}`)).size).toFixed(1) : 0
    };
    
    res.json(stats);
  } catch (error) {
    console.error('Errore statistiche assegnazioni:', error);
    res.status(500).json({ message: error.message });
  }
});

app.delete('/api/assegnazioni/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Soft delete - marca come non attiva
    const assegnazione = await Assegnazione.findByIdAndUpdate(
      id,
      { attiva: false },
      { new: true }
    );
    
    if (!assegnazione) {
      return res.status(404).json({ message: 'Assegnazione non trovata' });
    }
    
    res.json({ message: 'Assegnazione disattivata con successo' });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

// NUOVO: Hard delete - Eliminazione definitiva con ripristino utilizzi
app.delete('/api/assegnazioni/:id/permanent', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Trova l'assegnazione prima di eliminarla
    const assegnazione = await Assegnazione.findById(id);
    if (!assegnazione) {
      return res.status(404).json({ message: 'Assegnazione non trovata' });
    }
    
    // Inizia una transazione per garantire consistenza
    const session = await mongoose.startSession();
    session.startTransaction();
    
    try {
      // 1. Trova tutti gli utilizzi correlati a questa assegnazione
      const utilizzi = await Utilizzo.find({
        userId: assegnazione.userId,
        settimanaId: assegnazione.settimanaId,
        poloId: assegnazione.poloId,
        mezzoId: assegnazione.mezzoId
      }).session(session);
      
      // 2. Ripristina le quantit√† nelle giacenze per ogni utilizzo
      for (const utilizzo of utilizzi) {
        if (utilizzo.giacenzaUtenteId) {
          await GiacenzaUtente.findByIdAndUpdate(
            utilizzo.giacenzaUtenteId,
            { 
              $inc: { 
                quantitaDisponibile: utilizzo.quantitaUtilizzata 
              }
            },
            { session }
          );
        }
      }
      
      // 3. Elimina tutti gli utilizzi correlati
      await Utilizzo.deleteMany({
        userId: assegnazione.userId,
        settimanaId: assegnazione.settimanaId,
        poloId: assegnazione.poloId,
        mezzoId: assegnazione.mezzoId
      }).session(session);
      
      // 4. Elimina tutte le giacenze specifiche per questa assegnazione
      await GiacenzaUtente.deleteMany({
        userId: assegnazione.userId,
        settimanaId: assegnazione.settimanaId
      }).session(session);
      
      // 5. Elimina l'assegnazione stessa
      await Assegnazione.findByIdAndDelete(id).session(session);
      
      // Conferma la transazione
      await session.commitTransaction();
      
      res.json({ 
        message: 'Assegnazione eliminata definitivamente con successo',
        utilizziRipristinati: utilizzi.length,
        dettagli: {
          operatore: assegnazione.userId,
          settimana: assegnazione.settimanaId,
          polo: assegnazione.poloId,
          mezzo: assegnazione.mezzoId
        }
      });
      
    } catch (error) {
      // Annulla la transazione in caso di errore
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
    
  } catch (error) {
    console.error('Errore nell\'eliminazione definitiva:', error);
    res.status(500).json({ 
      message: 'Errore nell\'eliminazione definitiva dell\'assegnazione',
      error: error.message 
    });
  }
});

app.patch('/api/assegnazioni/:id/restore', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    const assegnazione = await Assegnazione.findByIdAndUpdate(
      id,
      { attiva: true },
      { new: true }
    ).populate('userId', 'username email')
     .populate('poloId', 'nome')
     .populate('mezzoId', 'nome')
     .populate('settimanaId', 'numero anno dataInizio dataFine');
    
    if (!assegnazione) {
      return res.status(404).json({ message: 'Assegnazione non trovata' });
    }
    
    res.json({ 
      message: 'Assegnazione ripristinata con successo',
      assegnazione 
    });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

// NUOVA: Copia giacenze da una settimana all'altra
app.post('/api/admin/copy-giacenze', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { userId, fromSettimanaId, toSettimanaId } = req.body;
    
    if (!userId || !fromSettimanaId || !toSettimanaId) {
      return res.status(400).json({ 
        message: 'userId, fromSettimanaId e toSettimanaId sono richiesti' 
      });
    }
    
    // Trova giacenze della settimana di origine
    const sourceGiacenze = await GiacenzaUtente.find({
      userId,
      settimanaId: fromSettimanaId,
      attiva: true
    });
    
    const copiedGiacenze = [];
    
    for (const sourceGiacenza of sourceGiacenze) {
      // Verifica se esiste gi√† nella settimana di destinazione
      const existingGiacenza = await GiacenzaUtente.findOne({
        userId,
        productId: sourceGiacenza.productId,
        settimanaId: toSettimanaId,
        attiva: true
      });
      
      if (!existingGiacenza) {
        // Crea nuova giacenza
        const newGiacenza = new GiacenzaUtente({
          userId: sourceGiacenza.userId,
          productId: sourceGiacenza.productId,
          settimanaId: toSettimanaId,
          quantitaAssegnata: sourceGiacenza.quantitaAssegnata,
          quantitaDisponibile: sourceGiacenza.quantitaAssegnata, // Reset alla quantit√† assegnata
          quantitaMinima: sourceGiacenza.quantitaMinima,
          note: `Copiata da settimana ${fromSettimanaId}`,
          assegnatoDa: req.user.userId,
          isGlobale: false
        });
        
        await newGiacenza.save();
        copiedGiacenze.push(newGiacenza);
      }
    }
    
    res.json({
      message: `Copiate ${copiedGiacenze.length} giacenze`,
      giacenze: copiedGiacenze
    });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

app.get('/api/users', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const users = await User.find({}, '-password');
    res.json(users);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// =============================================================================
// RDT ROUTES (Richiesta Di Trasferimento)
// =============================================================================

// GET - Lista RDT con filtri
app.get('/api/rdt', authenticateToken, async (req, res) => {
  try {
    const { 
      stato, 
      priorita, 
      cliente, 
      dataInizio, 
      dataFine, 
      limit = 50, 
      offset = 0,
      sortBy = 'createdAt',
      sortOrder = 'desc'
    } = req.query;

    // Costruisci filtro base
    const filter = { deleted: false };

    // Filtri opzionali
    if (stato && stato !== 'TUTTI') {
      filter.stato = stato;
    }
    if (priorita && priorita !== 'TUTTE') {
      filter.priorita = priorita;
    }
    if (cliente) {
      filter.cliente = new RegExp(cliente, 'i');
    }
    if (dataInizio || dataFine) {
      filter.dataConsegna = {};
      if (dataInizio) filter.dataConsegna.$gte = new Date(dataInizio);
      if (dataFine) filter.dataConsegna.$lte = new Date(dataFine);
    }

    // Costruisci sort object
    const sortObj = {};
    sortObj[sortBy] = sortOrder === 'desc' ? -1 : 1;

    const rdt = await RDT.find(filter)
      .populate('createdBy', 'username')
      .populate('lastModifiedBy', 'username')
      .populate('operatoreId', 'username email')
      .sort(sortObj)
      .limit(parseInt(limit))
      .skip(parseInt(offset));

    const total = await RDT.countDocuments(filter);

    res.json({
      rdt,
      pagination: {
        total,
        limit: parseInt(limit),
        offset: parseInt(offset),
        pages: Math.ceil(total / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Errore caricamento RDT:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET - Singolo RDT per ID
app.get('/api/rdt/:id', authenticateToken, async (req, res) => {
  try {
    const rdt = await RDT.findOne({ 
      _id: req.params.id, 
      deleted: false 
    })
    .populate('createdBy', 'username email')
    .populate('lastModifiedBy', 'username email');

    if (!rdt) {
      return res.status(404).json({ message: 'RDT non trovato' });
    }
    
    // üîç DEBUG: RDT restituito dal GET
    console.log('üîç DEBUG GET RDT: RDT restituito:', {
      numero: rdt.numero,
      prodotti: rdt.prodotti?.map(p => ({
        nome: p.nome,
        quantita: p.quantita,
        quantitaMinima: p.quantitaMinima || 'NON DEFINITA'
      })) || []
    });

    res.json(rdt);
  } catch (error) {
    console.error('Errore caricamento RDT:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Crea nuovo RDT
app.post('/api/rdt', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const {
      numero,
      cliente,
      dataConsegna,
      priorita,
      prodotti,
      valore,
      tempoStimato,
      indirizzo,
      contatti,
      note,
      operatoreId,
      assegnazioneId
    } = req.body;

    // Validazione campi obbligatori
    if (!numero || !cliente || !dataConsegna) {
      return res.status(400).json({ 
        message: 'Campi obbligatori mancanti: numero, cliente, dataConsegna' 
      });
    }

    // Verifica unicit√† numero RDT
    const existingRdt = await RDT.findOne({ numero, deleted: false });
    if (existingRdt) {
      return res.status(400).json({ 
        message: 'Numero RDT gi√† esistente' 
      });
    }

    // Calcola valore totale se non fornito
    let valoreCalcolato = valore || 0;
    if (prodotti && prodotti.length > 0 && !valore) {
      valoreCalcolato = prodotti.reduce((sum, prod) => {
        return sum + (prod.quantita * (prod.prezzo || 0));
      }, 0);
    }

    const nuovoRdt = new RDT({
      numero,
      cliente,
      dataConsegna: new Date(dataConsegna),
      priorita: priorita || 'MEDIA',
      prodotti: prodotti || [],
      valore: valoreCalcolato,
      tempoStimato: tempoStimato || 60,
      indirizzo: indirizzo || {},
      contatti: contatti || {},
      note: note || '',
      createdBy: req.user.userId,
      lastModifiedBy: req.user.userId,
      operatoreId: operatoreId || null // Salva operatore anche senza assegnazione
    });

    await nuovoRdt.save();

    // Se √® stata fornita un'assegnazione, collega l'RDT
    if (assegnazioneId) {
      const assegnazione = await Assegnazione.findById(assegnazioneId);
      if (assegnazione && assegnazione.attiva) {
        // Aggiorna l'assegnazione aggiungendo il riferimento all'RDT (numero)
        assegnazione.rdt = numero;
        await assegnazione.save();
      }
    }

    // RIMOSSO: Le giacenze vengono aggiornate solo alla finalizzazione dell'RDT
    
    const rdtPopulated = await RDT.findById(nuovoRdt._id)
      .populate('createdBy', 'username')
      .populate('lastModifiedBy', 'username');

    res.status(201).json(rdtPopulated);
  } catch (error) {
    console.error('Errore creazione RDT:', error);
    res.status(500).json({ message: error.message });
  }
});

// PUT - Aggiorna RDT
app.put('/api/rdt/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const updates = { ...req.body };
    delete updates._id; // Rimuovi _id dagli updates
    
    // üîç DEBUG: Log dei prodotti ricevuti
    if (updates.prodotti) {
      console.log('üîç DEBUG PUT RDT: Prodotti ricevuti:', updates.prodotti.map(p => ({
        nome: p.nome,
        quantita: p.quantita,
        quantitaMinima: p.quantitaMinima || 'NON DEFINITA'
      })));
    }
    
    // Aggiungi metadata di modifica
    updates.lastModifiedBy = req.user.userId;

    // Se cambiano i prodotti, ricalcola il valore
    if (updates.prodotti && !updates.valore) {
      updates.valore = updates.prodotti.reduce((sum, prod) => {
        return sum + (prod.quantita * (prod.prezzo || 0));
      }, 0);
    }

    const rdt = await RDT.findOneAndUpdate(
      { _id: req.params.id, deleted: false },
      updates,
      { new: true, runValidators: true }
    )
    .populate('createdBy', 'username')
    .populate('lastModifiedBy', 'username');

    if (!rdt) {
      return res.status(404).json({ message: 'RDT non trovato' });
    }
    
    // üîç DEBUG: RDT salvato nel DB
    console.log('üîç DEBUG PUT RDT - SALVATO NEL DB:', {
      numero: rdt.numero,
      prodotti: rdt.prodotti?.map(p => ({
        nome: p.nome,
        quantita: p.quantita,
        quantitaMinima: p.quantitaMinima || 'NON DEFINITA'
      })) || []
    });

    res.json(rdt);
  } catch (error) {
    console.error('Errore aggiornamento RDT:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Finalizza RDT (cambia stato a COMPLETATO e incrementa giacenze GLOBALI)
app.post('/api/rdt/:id/finalize', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Trova l'RDT
    const rdt = await RDT.findById(id);
    if (!rdt) {
      return res.status(404).json({ message: 'RDT non trovato' });
    }
    
    // üîç DEBUG: RDT caricato per finalizzazione
    console.log('üîç DEBUG FINALIZZAZIONE RDT: RDT caricato dal DB:', {
      numero: rdt.numero,
      prodotti: rdt.prodotti?.map(p => ({
        nome: p.nome,
        quantita: p.quantita,
        quantitaMinima: p.quantitaMinima || 'NON DEFINITA'
      })) || []
    });
    
    // Verifica che l'RDT non sia gi√† COMPLETATO
    if (rdt.stato === 'COMPLETATO') {
      return res.status(400).json({ message: 'RDT gi√† completato' });
    }

    // Cerca assegnazione (facoltativa)
    const assegnazione = await Assegnazione.findOne({
      rdt: rdt.numero,
      attiva: true
    }).populate('userId');

    // Determina operatoreId: da assegnazione o direttamente dall'RDT
    let operatoreId;
    if (assegnazione) {
      operatoreId = assegnazione.userId._id || assegnazione.userId;
    } else if (rdt.operatoreId) {
      operatoreId = rdt.operatoreId;
      console.log('üìù Finalizzazione RDT senza assegnazione - usando operatoreId dall\'RDT:', operatoreId);
    } else {
      return res.status(400).json({ message: 'Nessun operatore trovato per questo RDT (n√© assegnazione n√© operatoreId)' });
    }
    
    // DEBUG: Controlla giacenze globali esistenti per RDT
    const giacenzeGlobaliEsistentiRDT = await GiacenzaUtente.find({ isGlobale: true, attiva: true }).populate('productId', 'nome');
    console.log(`üîç DEBUG RDT: Giacenze globali esistenti (${giacenzeGlobaliEsistentiRDT.length}):`, giacenzeGlobaliEsistentiRDT.map(g => `${g.productId?.nome}: ${g.quantitaDisponibile}`));
    
    // Incrementa le giacenze GLOBALI per ogni prodotto nell'RDT
    if (rdt.prodotti && rdt.prodotti.length > 0) {
      console.log(`üîç DEBUG RDT: Prodotti nell'RDT da finalizzare:`, rdt.prodotti.map(p => ({
        nome: p.nome,
        quantita: p.quantita,
        quantitaMinima: p.quantitaMinima || 'NON DEFINITA'
      })));
      
      for (const prodotto of rdt.prodotti) {
        try {
          console.log(`üîç DEBUG RDT: Processando prodotto:`, {
            nome: prodotto.nome,
            quantita: prodotto.quantita,
            quantitaMinima: prodotto.quantitaMinima
          });
          
          // Trova il prodotto usando il nome per ottenere il productId
          const product = await Product.findOne({ nome: prodotto.nome, attivo: true });
          if (!product) {
            console.warn(`‚ö†Ô∏è Prodotto non trovato: ${prodotto.nome}`);
            continue;
          }

          // DEBUG: Log della ricerca giacenza globale
          console.log(`üîç DEBUG: Cercando giacenza globale per prodotto ${prodotto.nome} (ID: ${product._id})`);
          
          // Trova o crea giacenza GLOBALE per questo prodotto
          let giacenza = await GiacenzaUtente.findOne({
            productId: product._id,
            isGlobale: true,
            attiva: true
          });
          
          console.log(`üîç DEBUG: Giacenza globale trovata:`, giacenza ? 'SI' : 'NO');
          
          // Trova o crea giacenza GLOBALE dell'OPERATORE
          let giacenzaOperatore = await GiacenzaUtente.findOne({
            productId: product._id,
            userId: operatoreId,
            attiva: true
            // Nessun filtro su settimanaId - giacenza globale operatore
          });
          
          if (giacenzaOperatore && giacenzaOperatore.quantitaDisponibile > 0) {
            // Prodotto gi√† in giacenza CON quantit√† > 0 - aggiorna SOLO quantitaDisponibile
            giacenzaOperatore.quantitaDisponibile += prodotto.quantita;
            // NON toccare quantitaAssegnata (rimane quella esistente)
            // Mantieni quantitaMinima esistente o usa quella del prodotto se specificata
            if (prodotto.quantitaMinima !== undefined && prodotto.quantitaMinima > giacenzaOperatore.quantitaMinima) {
              giacenzaOperatore.quantitaMinima = prodotto.quantitaMinima;
            }
            await giacenzaOperatore.save();
            console.log(`‚úÖ Finalizzazione RDT - prodotto ${prodotto.nome} gi√† in giacenza: +${prodotto.quantita} (totale disp: ${giacenzaOperatore.quantitaDisponibile}, assegnata invariata: ${giacenzaOperatore.quantitaAssegnata}, min: ${giacenzaOperatore.quantitaMinima})`);
          } else {
            // Prodotto NON in giacenza O con giacenza = 0 - crea/aggiorna giacenza
            // quantitaAssegnata = quantitaDaAggiungere
            if (giacenzaOperatore) {
              // Giacenza esiste ma con quantit√† = 0 - aggiorna
              giacenzaOperatore.quantitaDisponibile = prodotto.quantita;
              giacenzaOperatore.quantitaAssegnata = prodotto.quantita; // Prende valore da "quantitaDaAggiungere"
              if (prodotto.quantitaMinima !== undefined) {
                giacenzaOperatore.quantitaMinima = prodotto.quantitaMinima;
              }
              await giacenzaOperatore.save();
              console.log(`‚úÖ Aggiornata giacenza a 0 per operatore ${assegnazione.userId.username} prodotto ${prodotto.nome}: disp=${giacenzaOperatore.quantitaDisponibile}, assegnata=${giacenzaOperatore.quantitaAssegnata}, min=${giacenzaOperatore.quantitaMinima}`);
            } else {
              // Crea completamente nuova giacenza
              giacenzaOperatore = new GiacenzaUtente({
                userId: assegnazione.userId._id,
                productId: product._id,
                quantitaDisponibile: prodotto.quantita,
                quantitaAssegnata: prodotto.quantita, // Prende valore da "quantitaDaAggiungere"
                quantitaMinima: prodotto.quantitaMinima || 0,
                attiva: true,
                isGlobale: true, // Giacenza globale dell'operatore
                note: `Giacenza globale creata dalla finalizzazione RDT ${rdt.numero}`,
                assegnatoDa: req.user.userId
                // Nessun settimanaId - giacenza globale operatore
              });
              await giacenzaOperatore.save();
              console.log(`‚úÖ Creata nuova giacenza globale per operatore ${assegnazione.userId.username} prodotto ${prodotto.nome}: disp=${giacenzaOperatore.quantitaDisponibile}, assegnata=${giacenzaOperatore.quantitaAssegnata}, min=${giacenzaOperatore.quantitaMinima}`);
            }
          }
          
          // üîç DEBUG: Verifica giacenza salvata
          const giacenzaVerifica = await GiacenzaUtente.findById(giacenzaOperatore._id);
          console.log(`üîç VERIFICA POST-SALVATAGGIO RDT - Giacenza ${prodotto.nome}:`, {
            quantitaDisponibile: giacenzaVerifica.quantitaDisponibile,
            quantitaAssegnata: giacenzaVerifica.quantitaAssegnata,
            quantitaMinima: giacenzaVerifica.quantitaMinima,
            isGlobale: giacenzaVerifica.isGlobale
          });
        } catch (prodottoError) {
          console.error(`Errore aggiornamento giacenze globali per prodotto ${prodotto.nome}:`, prodottoError);
        }
      }
    }
    
    // Cambia stato a COMPLETATO
    rdt.stato = 'COMPLETATO';
    await rdt.save();
    
    console.log(`‚úÖ RDT ${rdt.numero} finalizzato con successo e giacenze globali incrementate`);
    
    res.json({
      message: 'RDT finalizzato con successo e giacenze globali aggiornate',
      rdt: rdt
    });
  } catch (error) {
    console.error('Errore finalizzazione RDT:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Riapri RDT completato (cambia stato a CREATO e ripristina giacenze GLOBALI)
app.post('/api/rdt/:id/reopen', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Trova l'RDT
    const rdt = await RDT.findById(id);
    if (!rdt) {
      return res.status(404).json({ message: 'RDT non trovato' });
    }
    
    // Verifica che l'RDT sia COMPLETATO
    if (rdt.stato !== 'COMPLETATO') {
      return res.status(400).json({ message: 'Solo gli RDT completati possono essere riaperti' });
    }
    
    // Cerca assegnazione (facoltativa)
    const assegnazione = await Assegnazione.findOne({
      rdt: rdt.numero,
      attiva: true
    }).populate('userId');

    // Determina operatoreId: da assegnazione o direttamente dall'RDT
    let operatoreId;
    if (assegnazione) {
      operatoreId = assegnazione.userId._id || assegnazione.userId;
    } else if (rdt.operatoreId) {
      operatoreId = rdt.operatoreId;
      console.log('üìù Riapertura RDT senza assegnazione - usando operatoreId dall\'RDT:', operatoreId);
    } else {
      return res.status(400).json({ message: 'Nessun operatore trovato per questo RDT (n√© assegnazione n√© operatoreId)' });
    }

    // Decrementa le giacenze OPERATORE per ogni prodotto nell'RDT
    if (rdt.prodotti && rdt.prodotti.length > 0) {
      for (const prodotto of rdt.prodotti) {
        try {
          // Trova il prodotto usando il nome per ottenere il productId
          const product = await Product.findOne({ nome: prodotto.nome, attivo: true });
          if (!product) {
            console.warn(`‚ö†Ô∏è Prodotto non trovato nel database: ${prodotto.nome}`);
            continue;
          }

          // Trova la giacenza dell'OPERATORE per questo prodotto
          const giacenza = await GiacenzaUtente.findOne({
            productId: product._id,
            userId: operatoreId,
            isGlobale: true,  // Giacenze operative globali dell'operatore
            attiva: true
          });
          
          if (giacenza) {
            const giacenzaPrima = giacenza.quantitaDisponibile;
            
            // Sottrai la quantit√† dalle giacenze globali
            giacenza.quantitaDisponibile -= prodotto.quantita;
            giacenza.quantitaAssegnata -= prodotto.quantita;
            
            // Assicurati che non vadano sotto zero
            if (giacenza.quantitaDisponibile < 0) {
              giacenza.quantitaDisponibile = 0;
            }
            if (giacenza.quantitaAssegnata < 0) {
              giacenza.quantitaAssegnata = 0;
            }
            
            await giacenza.save();
            console.log(`üîÑ Decrementate giacenze operatore per prodotto ${prodotto.nome}: ${giacenzaPrima} ‚Üí ${giacenza.quantitaDisponibile} (-${prodotto.quantita})`);
          } else {
            console.warn(`‚ö†Ô∏è Giacenza operatore non trovata per prodotto ${prodotto.nome} - impossibile decrementare`);
          }
        } catch (prodottoError) {
          console.error(`‚ùå Errore decremento giacenze operatore per prodotto ${prodotto.nome}:`, prodottoError);
        }
      }
    }
    
    // Cambia stato a CREATO
    rdt.stato = 'CREATO';
    await rdt.save();
    
    console.log(`‚úÖ RDT ${rdt.numero} riaperto con successo, giacenze operatore decrementate`);
    
    res.json({
      message: 'RDT riaperto con successo e giacenze operatore decrementate',
      rdt: rdt
    });
  } catch (error) {
    console.error('Errore riapertura RDT:', error);
    res.status(500).json({ message: error.message });
  }
});

// DELETE - Elimina RDT (hard delete)
app.delete('/api/rdt/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    // HARD DELETE: Rimuovi fisicamente l'RDT dal database
    const rdt = await RDT.findByIdAndDelete(req.params.id);

    if (!rdt) {
      return res.status(404).json({ message: 'RDT non trovato' });
    }

    res.json({ 
      message: 'RDT eliminato definitivamente dal database',
      rdtDeletato: {
        id: rdt._id,
        numero: rdt.numero,
        cliente: rdt.cliente
      }
    });
  } catch (error) {
    console.error('Errore eliminazione RDT:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET - RDT disponibili per assegnazione
app.get('/api/rdt/disponibili', authenticateToken, async (req, res) => {
  try {
    const rdt = await RDT.find({ 
      deleted: false,
      stato: { $in: ['CREATO', 'ASSEGNATO'] }
    })
    .select('numero cliente dataConsegna priorita stato valore')
    .sort({ dataConsegna: 1, priorita: -1 });

    res.json(rdt);
  } catch (error) {
    console.error('Errore caricamento RDT disponibili:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET - Ricerca RDT
app.get('/api/rdt/ricerca', authenticateToken, async (req, res) => {
  try {
    const { q, limit = 10 } = req.query;
    
    if (!q || q.length < 2) {
      return res.json([]);
    }

    const searchFilter = {
      deleted: false,
      $or: [
        { numero: new RegExp(q, 'i') },
        { cliente: new RegExp(q, 'i') },
        { 'contatti.referente': new RegExp(q, 'i') }
      ]
    };

    const rdt = await RDT.find(searchFilter)
      .select('numero cliente dataConsegna priorita stato valore')
      .limit(parseInt(limit))
      .sort({ createdAt: -1 });

    res.json(rdt);
  } catch (error) {
    console.error('Errore ricerca RDT:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Aggiorna giacenze globali per ordini/RDT
app.post('/api/admin/giacenze/update-global', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { productId, quantitaUtilizzata, operazione, nota } = req.body;

    if (!productId || !quantitaUtilizzata || !operazione) {
      return res.status(400).json({ 
        message: 'Campi obbligatori: productId, quantitaUtilizzata, operazione' 
      });
    }

    // Trova tutte le giacenze globali per questo prodotto
    const giacenzeGlobali = await GiacenzaUtente.find({
      productId: productId,
      isGlobale: true,
      attiva: true
    }).populate('productId', 'nome');

    if (giacenzeGlobali.length === 0) {
      return res.status(404).json({ 
        message: 'Nessuna giacenza globale trovata per questo prodotto' 
      });
    }

    // Calcola la quantit√† da sottrarre per ogni giacenza
    const quantitaTotaleDisponibile = giacenzeGlobali.reduce((sum, g) => sum + g.quantitaDisponibile, 0);
    
    if (operazione === 'sottrai' && quantitaTotaleDisponibile < quantitaUtilizzata) {
      return res.status(400).json({ 
        message: `Quantit√† insufficiente. Disponibile: ${quantitaTotaleDisponibile}, Richiesta: ${quantitaUtilizzata}` 
      });
    }

    let quantitaRimanente = quantitaUtilizzata;
    const aggiornamenti = [];

    // Distribuisci la sottrazione/aggiunta tra le giacenze disponibili
    for (const giacenza of giacenzeGlobali) {
      if (quantitaRimanente <= 0) break;

      let quantitaDaModificare = 0;
      
      if (operazione === 'sottrai') {
        quantitaDaModificare = Math.min(giacenza.quantitaDisponibile, quantitaRimanente);
        giacenza.quantitaDisponibile -= quantitaDaModificare;
      } else if (operazione === 'aggiungi') {
        quantitaDaModificare = Math.min(
          giacenza.quantitaAssegnata - giacenza.quantitaDisponibile, 
          quantitaRimanente
        );
        giacenza.quantitaDisponibile += quantitaDaModificare;
      }

      if (quantitaDaModificare > 0) {
        await giacenza.save();
        quantitaRimanente -= quantitaDaModificare;
        
        aggiornamenti.push({
          giacenzaId: giacenza._id,
          quantitaModificata: quantitaDaModificare,
          nuovaQuantitaDisponibile: giacenza.quantitaDisponibile
        });

        // Registra il movimento come utilizzo se sottrazione
        if (operazione === 'sottrai') {
          const utilizzo = new Utilizzo({
            userId: giacenza.userId,
            productId: productId,
            quantitaUtilizzata: quantitaDaModificare,
            dataUtilizzo: new Date(),
            note: nota || `Ordine/RDT - Aggiornamento automatico giacenze`,
            assegnazioneId: null, // Nessuna assegnazione specifica
            postazioneId: null
          });
          await utilizzo.save();
        }
      }
    }

    res.json({
      message: `Giacenze aggiornate con successo (${operazione})`,
      prodotto: giacenzeGlobali[0].productId.nome,
      quantitaProcessata: quantitaUtilizzata - quantitaRimanente,
      quantitaRimanente: quantitaRimanente,
      aggiornamenti: aggiornamenti
    });

  } catch (error) {
    console.error('Errore aggiornamento giacenze globali:', error);
    res.status(500).json({ message: error.message });
  }
});

// PUT - Decrementa giacenze per eliminazione ordine/RDT
app.put('/api/admin/giacenze/decrement', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { userId, productId, quantity } = req.body;
    
    if (!userId || !productId || !quantity) {
      return res.status(400).json({ 
        message: 'Campi obbligatori: userId, productId, quantity' 
      });
    }
    
    const quantityNum = parseFloat(quantity);
    if (quantityNum <= 0) {
      return res.status(400).json({ message: 'La quantit√† deve essere maggiore di zero' });
    }
    
    // Trova la giacenza dell'operatore per questo prodotto
    const giacenza = await GiacenzaUtente.findOne({
      userId: userId,
      productId: productId,
      attiva: true
    });
    
    if (!giacenza) {
      return res.status(404).json({ 
        message: 'Giacenza non trovata per questo operatore e prodotto' 
      });
    }
    
    const giacenzaPrima = giacenza.quantitaDisponibile;
    
    // Sottrai la quantit√† dalla quantitaDisponibile
    giacenza.quantitaDisponibile -= quantityNum;
    
    // Assicurati che non vada sotto zero
    if (giacenza.quantitaDisponibile < 0) {
      giacenza.quantitaDisponibile = 0;
    }
    
    await giacenza.save();
    
    console.log(`üîÑ Giacenze decrementate per eliminazione: ${giacenzaPrima} ‚Üí ${giacenza.quantitaDisponibile} (-${quantityNum})`);
    
    res.json({
      message: 'Giacenze decrementate con successo',
      giacenzaPrima: giacenzaPrima,
      giacenzaDopo: giacenza.quantitaDisponibile,
      decrementata: quantityNum
    });
    
  } catch (error) {
    console.error('Errore decremento giacenze:', error);
    res.status(500).json({ message: error.message });
  }
});

// Route di test
app.get('/api/test', (req, res) => {
  res.json({ 
    message: 'Backend giacenze multi-settimana attivo!', 
    timestamp: new Date().toISOString(),
    version: '3.0 - Multi-Settimana'
  });
});

// Script di inizializzazione dati di test
async function initTestData() {
  try {
    // Verifica se ci sono gi√† dati
    const userCount = await User.countDocuments();
    
    if (userCount > 0) {
      console.log('Dati utenti gi√† presenti nel database');
      
      // ================================
      // AGGIORNA SOLO LE POSTAZIONI SE MANCANO
      // ================================
      
      const postazioniCount = await Postazione.countDocuments();
      
      if (postazioniCount === 0) {
        console.log('üè¢ Creazione postazioni di esempio...');
        
        // Trova admin esistente
        const admin = await User.findOne({ role: 'admin' });
        if (!admin) {
          console.log('‚ùå Admin non trovato per creare postazioni');
          return;
        }
        
        // Trova poli esistenti (CORRETTO: usa poli invece di settimane)
        const poli = await Polo.find().sort({ nome: 1 });
        if (poli.length === 0) {
          console.log('‚ùå Nessun polo trovato per creare postazioni');
          return;
        }
        
        const postazioni = [];
        for (let i = 0; i < poli.length; i++) {
          const polo = poli[i];
          
          // Crea 3-5 postazioni per polo
          const numPostazioni = Math.floor(Math.random() * 3) + 3; // 3-5 postazioni
          
          for (let j = 1; j <= numPostazioni; j++) {
            const postazione = await Postazione.create({
              nome: `Postazione ${String.fromCharCode(64 + j)}`, // A, B, C, D, E
              descrizione: `Postazione di lavoro ${j} nel ${polo.nome}`,
              poloId: polo._id, // ‚Üê CORRETTO: usa poloId
              indirizzo: `Via ${polo.nome} ${j * 10}, Milano`,
              coordinate: {
                lat: 45.464664 + (Math.random() - 0.5) * 0.1,
                lng: 9.188540 + (Math.random() - 0.5) * 0.1
              },
              capacitaPersone: Math.floor(Math.random() * 4) + 1, // 1-4 persone
              attrezzature: [
                'Computer portatile',
                'Telefono',
                Math.random() > 0.5 ? 'Stampante' : 'Scanner',
                Math.random() > 0.7 ? 'Proiettore' : 'Lavagna'
              ].filter(Boolean),
              note: `Postazione creata automaticamente per test nel ${polo.nome}`,
              createdBy: admin._id
            });
            postazioni.push(postazione);
          }
        }
        
        console.log(`‚úÖ Create ${postazioni.length} postazioni di esempio per ${poli.length} poli`);
      } else {
        console.log(`üè¢ Postazioni gi√† presenti: ${postazioniCount}`);
      }
      
      return; // Esce qui se i dati principali esistono gi√†
    }

    console.log('Inizializzazione completa dati di test...');

    // Crea utenti
    const adminPassword = await bcrypt.hash('password123', 10);
    const userPassword = await bcrypt.hash('password123', 10);

    const admin = await User.create({
      username: 'admin',
      password: adminPassword,
      email: 'admin@test.com',
      role: 'admin'
    });

    const user1 = await User.create({
      username: 'operatore1',
      password: userPassword,
      email: 'operatore1@test.com',
      role: 'user'
    });

    const user2 = await User.create({
      username: 'operatore2',
      password: userPassword,
      email: 'operatore2@test.com',
      role: 'user'
    });

    // Crea prodotti
    const prodotti = [
      { nome: 'Guanti in lattice', categoria: 'DPI', unita: 'paia', descrizione: 'Guanti monouso' },
      { nome: 'Mascherine FFP2', categoria: 'DPI', unita: 'pz', descrizione: 'Mascherine protettive' },
      { nome: 'Gel igienizzante', categoria: 'Igiene', unita: 'flaconi', descrizione: '500ml' },
      { nome: 'Sacchi spazzatura', categoria: 'Pulizia', unita: 'pz', descrizione: '70x110cm' },
      { nome: 'Detergente pavimenti', categoria: 'Pulizia', unita: 'litri', descrizione: 'Detergente universale' }
    ];

    const createdProducts = [];
    for (const prod of prodotti) {
      const product = await Product.create(prod);
      createdProducts.push(product);
    }

    // Crea poli
    const poli = await Polo.create([
      { nome: 'Polo Nord', descrizione: 'Area nord della citt√†' },
      { nome: 'Polo Sud', descrizione: 'Area sud della citt√†' },
      { nome: 'Polo Centro', descrizione: 'Centro citt√†' }
    ]);

    // Crea mezzi
    const mezzi = await Mezzo.create([
      { nome: 'Furgone 1', descrizione: 'Fiat Ducato' },
      { nome: 'Furgone 2', descrizione: 'Iveco Daily' },
      { nome: 'Auto 1', descrizione: 'Fiat Panda' }
    ]);

    // Crea settimane
    const currentDate = new Date();
    const settimane = [];
    
    for (let i = 0; i < 4; i++) {
      const startDate = new Date(currentDate);
      startDate.setDate(startDate.getDate() - (7 * i));
      startDate.setHours(0, 0, 0, 0);
      
      const endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + 6);
      endDate.setHours(23, 59, 59, 999);
      
      const weekNumber = Math.ceil((startDate.getDate() + startDate.getDay()) / 7);
      
      const settimana = await Settimana.create({
        numero: weekNumber,
        anno: startDate.getFullYear(),
        dataInizio: startDate,
        dataFine: endDate
      });
      settimane.push(settimana);
    }

    // Crea assegnazioni
    await Assegnazione.create({
      userId: user1._id,
      poloId: poli[0]._id,
      mezzoId: mezzi[0]._id,
      settimanaId: settimane[0]._id,
      createdBy: admin._id
    });

    await Assegnazione.create({
      userId: user1._id,
      poloId: poli[1]._id,
      mezzoId: mezzi[1]._id,
      settimanaId: settimane[1]._id,
      createdBy: admin._id
    });

    // Crea alcune giacenze globali di esempio
    for (const user of [user1, user2]) {
      for (let i = 0; i < 3; i++) {
        await GiacenzaUtente.create({
          userId: user._id,
          productId: createdProducts[i]._id,
          quantitaAssegnata: 100,
          quantitaDisponibile: 100,
          quantitaMinima: 20,
          assegnatoDa: admin._id,
          isGlobale: true,
          note: 'Giacenza iniziale'
        });
      }
    }
    
    // ================================
    // CREA POSTAZIONI (CORRETTO - COLLEGATO AI POLI)
    // ================================
    
    // Crea postazioni di esempio collegate ai poli
    const postazioni = [];
    for (let i = 0; i < poli.length; i++) {
      const polo = poli[i];
      
      // Crea 2-4 postazioni per polo
      const numPostazioni = Math.floor(Math.random() * 3) + 2; // 2-4 postazioni
      
      for (let j = 1; j <= numPostazioni; j++) {
        const postazione = await Postazione.create({
          nome: `Postazione ${String.fromCharCode(64 + j)}`, // A, B, C, D
          descrizione: `Postazione di lavoro ${j} nel ${polo.nome}`,
          poloId: polo._id, // ‚Üê CORRETTO: collegato al polo
          indirizzo: `Via ${polo.nome} ${j * 10}, Milano`,
          coordinate: {
            lat: 45.464664 + (Math.random() - 0.5) * 0.1,
            lng: 9.188540 + (Math.random() - 0.5) * 0.1
          },
          capacitaPersone: Math.floor(Math.random() * 4) + 1, // 1-4 persone
          attrezzature: [
            'Computer portatile',
            'Telefono',
            Math.random() > 0.5 ? 'Stampante' : 'Scanner',
            Math.random() > 0.7 ? 'Proiettore' : 'Lavagna'
          ].filter(Boolean),
          note: `Postazione creata automaticamente per test nel ${polo.nome}`,
          createdBy: admin._id
        });
        postazioni.push(postazione);
      }
    }

    console.log(`‚úÖ Create ${postazioni.length} postazioni per ${poli.length} poli`);
    console.log('‚úÖ Dati di test inizializzati con successo!');
    console.log('üìã Utenti creati:');
    console.log('   - admin / password123');
    console.log('   - operatore1 / password123');
    console.log('   - operatore2 / password123');
    
  } catch (error) {
    console.error('‚ùå Errore inizializzazione dati:', error);
  }
}

// ================================
// FUNZIONE HELPER CORRETTA PER FORZARE CREAZIONE POSTAZIONI
// ================================

async function forceCreatePostazioni() {
  try {
    console.log('üîÑ Forzatura creazione postazioni...');
    
    // Elimina postazioni esistenti (opzionale)
    const deletedCount = await Postazione.deleteMany({});
    console.log(`üóëÔ∏è  Eliminate ${deletedCount.deletedCount} postazioni esistenti`);
    
    // Trova admin e poli (CORRETTO)
    const admin = await User.findOne({ role: 'admin' });
    const poli = await Polo.find().sort({ nome: 1 });
    
    if (!admin || poli.length === 0) {
      console.log('‚ùå Admin o poli non trovati');
      return;
    }
    
    const postazioni = [];
    for (let i = 0; i < poli.length; i++) {
      const polo = poli[i];
      
      // Crea 4 postazioni per polo (numero fisso per test)
      for (let j = 1; j <= 4; j++) {
        const postazione = await Postazione.create({
          nome: `Postazione ${String.fromCharCode(64 + j)}`,
          descrizione: `Postazione di lavoro ${j} nel ${polo.nome}`,
          poloId: polo._id, // ‚Üê CORRETTO: collegato al polo
          indirizzo: `Via ${polo.nome} ${j * 10}, Milano`,
          coordinate: {
            lat: 45.464664 + (Math.random() - 0.5) * 0.1,
            lng: 9.188540 + (Math.random() - 0.5) * 0.1
          },
          capacitaPersone: Math.floor(Math.random() * 4) + 1,
          attrezzature: [
            'Computer portatile',
            'Telefono',
            Math.random() > 0.5 ? 'Stampante' : 'Scanner',
            Math.random() > 0.7 ? 'Proiettore' : 'Lavagna'
          ].filter(Boolean),
          note: `Postazione creata forzatamente per test - ${new Date().toLocaleString()}`,
          createdBy: admin._id
        });
        postazioni.push(postazione);
      }
    }
    
    console.log(`‚úÖ Forza-create ${postazioni.length} postazioni per ${poli.length} poli`);
    return postazioni;
    
  } catch (error) {
    console.error('‚ùå Errore forzatura postazioni:', error);
  }
}

// ================================
// FUNZIONE HELPER PER FORZARE CREAZIONE POSTAZIONI
// ================================

// Aggiungi anche questa funzione helper che puoi chiamare manualmente se necessario
async function forceCreatePostazioni() {
  try {
    console.log('üîÑ Forzatura creazione postazioni...');
    
    // Elimina postazioni esistenti (opzionale)
    const deletedCount = await Postazione.deleteMany({});
    console.log(`üóëÔ∏è  Eliminate ${deletedCount.deletedCount} postazioni esistenti`);
    
    // Trova admin e settimane
    const admin = await User.findOne({ role: 'admin' });
    const settimane = await Settimana.find().sort({ anno: -1, numero: -1 });
    
    if (!admin || settimane.length === 0) {
      console.log('‚ùå Admin o settimane non trovati');
      return;
    }
    
    const postazioni = [];
    for (let i = 0; i < settimane.length; i++) {
      const settimana = settimane[i];
      
      // Crea 4 postazioni per settimana (numero fisso per test)
      for (let j = 1; j <= 4; j++) {
        const postazione = await Postazione.create({
          nome: `Postazione ${String.fromCharCode(64 + j)}`,
          descrizione: `Postazione di lavoro ${j} per settimana ${settimana.numero}/${settimana.anno}`,
          settimanaId: settimana._id,
          indirizzo: `Via Roma ${j * 10}, Milano`,
          coordinate: {
            lat: 45.464664 + (Math.random() - 0.5) * 0.1,
            lng: 9.188540 + (Math.random() - 0.5) * 0.1
          },
          capacitaPersone: Math.floor(Math.random() * 4) + 1,
          attrezzature: [
            'Computer portatile',
            'Telefono',
            Math.random() > 0.5 ? 'Stampante' : 'Scanner',
            Math.random() > 0.7 ? 'Proiettore' : 'Lavagna'
          ].filter(Boolean),
          note: `Postazione creata forzatamente per test - ${new Date().toLocaleString()}`,
          createdBy: admin._id
        });
        postazioni.push(postazione);
      }
    }
    
    console.log(`‚úÖ Forza-create ${postazioni.length} postazioni per ${settimane.length} settimane`);
    return postazioni;
    
  } catch (error) {
    console.error('‚ùå Errore forzatura postazioni:', error);
  }
}

// ================================
// ENDPOINT PER TESTARE POSTAZIONI (AGGIUNGILO TEMPORANEAMENTE)
// ================================

// Aggiungi questo endpoint temporaneo per testare la creazione delle postazioni
app.post('/api/test/force-postazioni', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const result = await forceCreatePostazioni();
    res.json({
      message: 'Postazioni create forzatamente',
      count: result ? result.length : 0,
      postazioni: result
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
// ================================
// ENDPOINT GESTIONE UTENTI (ADMIN)
// ================================

// GET - Lista tutti gli utenti (Admin)
app.get('/api/admin/users', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const users = await User.find({}, '-password')
      .sort({ createdAt: -1 });
    res.json(users);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// POST - Crea nuovo utente (Admin)
app.post('/api/admin/users', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { username, email, password, role = 'user' } = req.body;

    // Validazioni
    if (!username || !email || !password) {
      return res.status(400).json({ message: 'Username, email e password sono obbligatori' });
    }

    if (password.length < 6) {
      return res.status(400).json({ message: 'La password deve essere di almeno 6 caratteri' });
    }

    // Verifica se username o email esistono gi√†
    const existingUser = await User.findOne({
      $or: [{ username }, { email }]
    });

    if (existingUser) {
      return res.status(400).json({ 
        message: existingUser.username === username 
          ? 'Username gi√† esistente' 
          : 'Email gi√† esistente' 
      });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Crea utente
    const newUser = new User({
      username,
      email,
      password: hashedPassword,
      role: ['admin', 'user'].includes(role) ? role : 'user'
    });

    await newUser.save();

    // Restituisce utente senza password
    const userResponse = await User.findById(newUser._id, '-password');
    
    res.status(201).json({
      message: 'Utente creato con successo',
      user: userResponse
    });
  } catch (error) {
    if (error.code === 11000) {
      const field = Object.keys(error.keyPattern)[0];
      return res.status(400).json({ 
        message: field === 'username' ? 'Username gi√† esistente' : 'Email gi√† esistente'
      });
    }
    res.status(400).json({ message: error.message });
  }
});

// PUT - Modifica utente (Admin)
app.put('/api/admin/users/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { username, email, role } = req.body;

    // Validazioni
    if (!username || !email) {
      return res.status(400).json({ message: 'Username e email sono obbligatori' });
    }

    // Verifica se l'utente esiste
    const user = await User.findById(id);
    if (!user) {
      return res.status(404).json({ message: 'Utente non trovato' });
    }

    // Verifica se username/email sono gi√† usati da altri utenti
    const existingUser = await User.findOne({
      _id: { $ne: id },
      $or: [{ username }, { email }]
    });

    if (existingUser) {
      return res.status(400).json({ 
        message: existingUser.username === username 
          ? 'Username gi√† utilizzato da un altro utente' 
          : 'Email gi√† utilizzata da un altro utente' 
      });
    }

    // Aggiorna utente
    const updatedUser = await User.findByIdAndUpdate(
      id,
      {
        username,
        email,
        role: ['admin', 'user'].includes(role) ? role : user.role
      },
      { new: true, select: '-password' }
    );

    res.json({
      message: 'Utente aggiornato con successo',
      user: updatedUser
    });
  } catch (error) {
    if (error.code === 11000) {
      const field = Object.keys(error.keyPattern)[0];
      return res.status(400).json({ 
        message: field === 'username' ? 'Username gi√† utilizzato' : 'Email gi√† utilizzata'
      });
    }
    res.status(400).json({ message: error.message });
  }
});

// DELETE - Elimina utente (Admin)
app.delete('/api/admin/users/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    // Verifica se l'utente esiste
    const user = await User.findById(id);
    if (!user) {
      return res.status(404).json({ message: 'Utente non trovato' });
    }

    // Impedisci di eliminare se stesso
    if (id === req.user.userId) {
      return res.status(400).json({ message: 'Non puoi eliminare il tuo account' });
    }

    // Elimina giacenze associate
    await GiacenzaUtente.deleteMany({ userId: id });
    
    // Elimina utilizzi associati
    await Utilizzo.deleteMany({ userId: id });
    
    // Elimina assegnazioni associate
    await Assegnazione.deleteMany({ userId: id });

    // Elimina utente
    await User.findByIdAndDelete(id);

    res.json({
      message: 'Utente e tutti i dati associati eliminati con successo',
      deletedUser: {
        id: user._id,
        username: user.username,
        email: user.email
      }
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// POST - Reset password utente (Admin)
app.post('/api/admin/users/:id/reset-password', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { newPassword } = req.body;

    if (!newPassword || newPassword.length < 6) {
      return res.status(400).json({ message: 'La password deve essere di almeno 6 caratteri' });
    }

    // Verifica se l'utente esiste
    const user = await User.findById(id);
    if (!user) {
      return res.status(404).json({ message: 'Utente non trovato' });
    }

    // Hash nuova password
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // Aggiorna password
    await User.findByIdAndUpdate(id, { password: hashedPassword });

    res.json({
      message: 'Password di ' + user.username + ' aggiornata con successo'
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// ================================
// ENDPOINT GESTIONE PRODOTTI (ADMIN)
// ================================

// GET - Lista tutti i prodotti (Admin)
app.get('/api/admin/products', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { categoria, attivo } = req.query;
    
    const filter = {};
    if (categoria) filter.categoria = categoria;
    if (attivo !== undefined) filter.attivo = attivo === 'true';
    
    const products = await Product.find(filter)
      .sort({ createdAt: -1 });
    
    res.json(products);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// POST - Crea nuovo prodotto (Admin)
app.post('/api/admin/products', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { nome, codice, descrizione, categoria, unita = 'pz', attivo = true } = req.body;

    // Validazioni
    if (!nome || !categoria) {
      return res.status(400).json({ message: 'Nome e categoria sono obbligatori' });
    }

    // Verifica se il prodotto esiste gi√† (case insensitive)
    const nomeRegex = new RegExp('^' + nome.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'i');
    const categoriaRegex = new RegExp('^' + categoria.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'i');

    const existingProduct = await Product.findOne({
      nome: { $regex: nomeRegex },
      categoria: { $regex: categoriaRegex }
    });

    if (existingProduct) {
      return res.status(400).json({
        message: 'Prodotto con questo nome e categoria gi√† esistente'
      });
    }

    // Crea prodotto
    const newProduct = new Product({
      nome: nome.trim(),
      codice: codice ? codice.trim() : '',
      descrizione: descrizione ? descrizione.trim() : '',
      categoria: categoria.trim(),
      unita: unita.trim(),
      attivo: Boolean(attivo)
    });

    await newProduct.save();
    
    res.status(201).json({
      message: 'Prodotto creato con successo',
      product: newProduct
    });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

// PUT - Modifica prodotto (Admin)
app.put('/api/admin/products/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { nome, codice, descrizione, categoria, unita, attivo } = req.body;

    // Validazioni
    if (!nome || !categoria) {
      return res.status(400).json({ message: 'Nome e categoria sono obbligatori' });
    }

    // Verifica se il prodotto esiste
    const product = await Product.findById(id);
    if (!product) {
      return res.status(404).json({ message: 'Prodotto non trovato' });
    }

    // Verifica se nome/categoria sono gi√† usati da altri prodotti
    const nomeRegex = new RegExp('^' + nome.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'i');
    const categoriaRegex = new RegExp('^' + categoria.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'i');

    const existingProduct = await Product.findOne({
      _id: { $ne: id },
      nome: { $regex: nomeRegex },
      categoria: { $regex: categoriaRegex }
    });

    if (existingProduct) {
      return res.status(400).json({
        message: 'Un altro prodotto ha gi√† questo nome e categoria'
      });
    }

    // Aggiorna prodotto
    const updatedProduct = await Product.findByIdAndUpdate(
      id,
      {
        nome: nome.trim(),
        codice: codice ? codice.trim() : '',
        descrizione: descrizione ? descrizione.trim() : '',
        categoria: categoria.trim(),
        unita: unita ? unita.trim() : product.unita,
        attivo: attivo !== undefined ? Boolean(attivo) : product.attivo
      },
      { new: true }
    );

    res.json({
      message: 'Prodotto aggiornato con successo',
      product: updatedProduct
    });
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

// DELETE - Elimina prodotto (Admin)
app.delete('/api/admin/products/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    // Verifica se il prodotto esiste
    const product = await Product.findById(id);
    if (!product) {
      return res.status(404).json({ message: 'Prodotto non trovato' });
    }

    // Verifica se ci sono giacenze associate
    const giacenzeCount = await GiacenzaUtente.countDocuments({ productId: id });
    if (giacenzeCount > 0) {
      return res.status(400).json({ 
        message: 'Impossibile eliminare: ci sono ' + giacenzeCount + ' giacenze associate a questo prodotto. Elimina prima le giacenze.'
      });
    }

    // Verifica se ci sono utilizzi associati
    const utilizziCount = await Utilizzo.countDocuments({ productId: id });
    if (utilizziCount > 0) {
      return res.status(400).json({ 
        message: 'Impossibile eliminare: ci sono ' + utilizziCount + ' utilizzi registrati per questo prodotto. Considera di disattivarlo invece di eliminarlo.'
      });
    }

    // Elimina prodotto
    await Product.findByIdAndDelete(id);

    res.json({
      message: 'Prodotto eliminato con successo',
      deletedProduct: {
        id: product._id,
        nome: product.nome,
        categoria: product.categoria
      }
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// PATCH - Toggle stato attivo prodotto (Admin)
app.patch('/api/admin/products/:id/toggle', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { attivo } = req.body;

    // Verifica se il prodotto esiste
    const product = await Product.findById(id);
    if (!product) {
      return res.status(404).json({ message: 'Prodotto non trovato' });
    }

    // Aggiorna stato
    const updatedProduct = await Product.findByIdAndUpdate(
      id,
      { attivo: Boolean(attivo) },
      { new: true }
    );

    // Se viene disattivato, verifica giacenze attive
    if (!attivo) {
      const giacenzeAttive = await GiacenzaUtente.countDocuments({ 
        productId: id, 
        attiva: true,
        quantitaDisponibile: { $gt: 0 }
      });
      
      if (giacenzeAttive > 0) {
        return res.json({
          message: 'Prodotto disattivato con successo',
          product: updatedProduct,
          warning: 'Attenzione: ci sono ancora ' + giacenzeAttive + ' giacenze attive per questo prodotto'
        });
      }
    }

    res.json({
      message: 'Prodotto ' + (attivo ? 'attivato' : 'disattivato') + ' con successo',
      product: updatedProduct
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

app.get('/api/postazioni', authenticateToken, async (req, res) => {
  try {
    const { 
      poloId, 
      attiva, 
      searchTerm,
      capacitaMin,
      capacitaMax
    } = req.query;
    
    const filter = {};
    
    // Filtri base
    if (poloId) filter.poloId = poloId;
    if (attiva !== undefined) filter.attiva = attiva === 'true';
    
    console.log('üè¢ Filtri postazioni:', filter);
    
    const postazioni = await Postazione.find(filter)
      .populate('poloId', 'nome descrizione') // ‚Üê CAMBIATO: popola polo invece di settimana
      .populate('createdBy', 'username')
      .sort({ 'poloId.nome': 1, nome: 1 });

    let filteredPostazioni = postazioni;

    // Filtro ricerca libera
    if (searchTerm) {
      const term = searchTerm.toLowerCase();
      filteredPostazioni = filteredPostazioni.filter(p => 
        p.nome.toLowerCase().includes(term) ||
        p.descrizione?.toLowerCase().includes(term) ||
        p.indirizzo?.toLowerCase().includes(term) ||
        p.note?.toLowerCase().includes(term) ||
        p.poloId?.nome.toLowerCase().includes(term) || // ‚Üê CAMBIATO: cerca nel nome polo
        p.attrezzature?.some(att => att.toLowerCase().includes(term))
      );
    }

    // Filtri numerici per capacit√†
    if (capacitaMin) {
      const min = parseInt(capacitaMin);
      filteredPostazioni = filteredPostazioni.filter(p => p.capacitaPersone >= min);
    }
    
    if (capacitaMax) {
      const max = parseInt(capacitaMax);
      filteredPostazioni = filteredPostazioni.filter(p => p.capacitaPersone <= max);
    }

    console.log(`üìä Postazioni risultati: ${filteredPostazioni.length} di ${postazioni.length}`);

    res.json(filteredPostazioni);
  } catch (error) {
    console.error('‚ùå Errore caricamento postazioni:', error);
    res.status(500).json({ message: error.message });
  }
});

// =====================================================
// EXCEL IMPORT/EXPORT ROUTES - Must be before /:id route
// =====================================================

// GET - Download template Excel per postazioni
app.get('/api/postazioni/template', authenticateToken, requireAdmin, async (req, res) => {
  try {
    // Carica i poli per il template
    const poli = await Polo.find({}, 'nome').sort({ nome: 1 });
    
    // Crea dati di esempio per il template
    const templateData = [
      {
        nome: 'Postazione Esempio 1',
        polo: poli.length > 0 ? poli[0].nome : 'Polo Nord',
        indirizzo: 'Via Roma 123, Milano',
        latitudine: 45.464664,
        longitudine: 9.188540
      },
      {
        nome: 'Postazione Esempio 2', 
        polo: poli.length > 1 ? poli[1].nome : 'Polo Sud',
        indirizzo: 'Via Dante 456, Milano',
        latitudine: 45.466797,
        longitudine: 9.190544
      }
    ];

    // Crea workbook Excel
    const workbook = xlsx.utils.book_new();
    const worksheet = xlsx.utils.json_to_sheet(templateData);
    
    // Imposta larghezza delle colonne
    worksheet['!cols'] = [
      { wch: 20 }, // nome
      { wch: 15 }, // polo
      { wch: 30 }, // indirizzo  
      { wch: 12 }, // latitudine
      { wch: 12 }  // longitudine
    ];

    xlsx.utils.book_append_sheet(workbook, worksheet, 'Postazioni');
    
    // Genera buffer Excel
    const buffer = xlsx.write(workbook, { type: 'buffer', bookType: 'xlsx' });
    
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', 'attachment; filename=template_postazioni.xlsx');
    res.send(buffer);
    
    console.log('‚úÖ Template Excel scaricato con successo');
    
  } catch (error) {
    console.error('‚ùå Errore download template:', error);
    res.status(500).json({ message: 'Errore nel download del template' });
  }
});

// POST - Import Excel postazioni
app.post('/api/postazioni/import', authenticateToken, requireAdmin, async (req, res) => {
  try {
    console.log('üìÅ Inizio import Excel postazioni');
    
    if (!req.files || !req.files.file) {
      return res.status(400).json({ message: 'Nessun file caricato' });
    }

    const file = req.files.file;
    console.log('üìÅ File ricevuto:', file.name, 'Size:', file.size);
    
    // Verifica che sia un file Excel
    if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
      return res.status(400).json({ message: 'Il file deve essere in formato Excel (.xlsx o .xls)' });
    }

    // Leggi il file Excel
    const workbook = xlsx.read(file.data, { type: 'buffer' });
    const worksheet = workbook.Sheets[workbook.SheetNames[0]];
    const data = xlsx.utils.sheet_to_json(worksheet);

    console.log('üìä Dati letti da Excel:', data.length, 'righe');

    if (!data || data.length === 0) {
      return res.status(400).json({ message: 'Il file Excel √® vuoto o non contiene dati validi' });
    }

    let created = 0;
    let updated = 0;
    let errors = 0;
    const errorMessages = [];

    // Carica tutti i poli per la ricerca
    const poli = await Polo.find({});
    const poliMap = {};
    poli.forEach(polo => {
      poliMap[polo.nome.toLowerCase()] = polo._id;
    });

    console.log('üè¢ Poli disponibili:', Object.keys(poliMap));

    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      const rowNum = i + 2; // +2 perch√© Excel inizia da 1 e abbiamo header
      
      try {
        // Validazione campi obbligatori
        if (!row.nome || !row.polo) {
          throw new Error(`Riga ${rowNum}: Nome e polo sono obbligatori`);
        }

        // Trova il polo
        const poloId = poliMap[row.polo.toLowerCase()];
        if (!poloId) {
          throw new Error(`Riga ${rowNum}: Polo "${row.polo}" non trovato`);
        }

        // Prepara i dati della postazione
        const postazioneData = {
          nome: row.nome.trim(),
          poloId: poloId,
          indirizzo: row.indirizzo ? row.indirizzo.trim() : '',
          coordinate: {
            lat: row.latitudine ? parseFloat(row.latitudine) : '',
            lng: row.longitudine ? parseFloat(row.longitudine) : ''
          }
        };

        // Verifica se la postazione esiste gi√† (stesso nome e polo)
        const existingPostazione = await Postazione.findOne({
          nome: postazioneData.nome,
          poloId: poloId
        });

        if (existingPostazione) {
          // Aggiorna postazione esistente
          await Postazione.findByIdAndUpdate(existingPostazione._id, postazioneData);
          updated++;
          console.log(`‚úèÔ∏è  Aggiornata: ${postazioneData.nome}`);
        } else {
          // Crea nuova postazione
          const newPostazione = new Postazione(postazioneData);
          await newPostazione.save();
          created++;
          console.log(`‚ûï Creata: ${postazioneData.nome}`);
        }

      } catch (error) {
        errors++;
        errorMessages.push(error.message);
        console.error(`‚ùå Errore riga ${rowNum}:`, error.message);
      }
    }

    console.log(`üìä Import completato: ${created} create, ${updated} aggiornate, ${errors} errori`);
    
    res.json({
      message: 'Import completato',
      created,
      updated,
      errors,
      errorMessages: errorMessages.slice(0, 10) // Limita a 10 errori per evitare risposte troppo grandi
    });

  } catch (error) {
    console.error('‚ùå Errore import Excel:', error);
    res.status(500).json({ message: 'Errore nell\'import del file Excel' });
  }
});

// GET - Postazione singola per ID
app.get('/api/postazioni/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    const postazione = await Postazione.findById(id)
      .populate('poloId', 'nome descrizione') // ‚Üê CAMBIATO
      .populate('createdBy', 'username email');

    if (!postazione) {
      return res.status(404).json({ message: 'Postazione non trovata' });
    }

    res.json(postazione);
  } catch (error) {
    console.error('‚ùå Errore caricamento postazione:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET - Postazioni per polo specifico
app.get('/api/postazioni/polo/:poloId', authenticateToken, async (req, res) => {
  try {
    const { poloId } = req.params;
    const { attiva = 'true' } = req.query;
    
    const filter = { poloId };
    if (attiva !== undefined) filter.attiva = attiva === 'true';
    
    const postazioni = await Postazione.find(filter)
      .populate('poloId', 'nome descrizione')
      .populate('createdBy', 'username')
      .sort({ nome: 1 });

    res.json(postazioni);
  } catch (error) {
    console.error('‚ùå Errore caricamento postazioni per polo:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Crea nuova postazione (Admin)
app.post('/api/postazioni', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { 
      nome, 
      descrizione, 
      poloId, // ‚Üê CAMBIATO: da settimanaId a poloId
      indirizzo,
      coordinate,
      capacitaPersone = 1,
      attrezzature = [],
      note,
      attiva = true
    } = req.body;

    // Validazioni
    if (!nome || !poloId) {
      return res.status(400).json({ message: 'Nome e poloId sono obbligatori' });
    }

    // Verifica che il polo esista
    const polo = await Polo.findById(poloId);
    if (!polo) {
      return res.status(404).json({ message: 'Polo non trovato' });
    }

    // Verifica se postazione con stesso nome esiste gi√† per questo polo
    const existingPostazione = await Postazione.findOne({ 
      nome: { $regex: new RegExp('^' + nome.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'i') },
      poloId
    });

    if (existingPostazione) {
      return res.status(400).json({ 
        message: 'Postazione con questo nome gi√† esistente per questo polo' 
      });
    }

    // Crea postazione
    const newPostazione = new Postazione({
      nome: nome.trim(),
      descrizione: descrizione ? descrizione.trim() : '',
      poloId,
      indirizzo: indirizzo ? indirizzo.trim() : '',
      coordinate: coordinate || {},
      capacitaPersone: parseInt(capacitaPersone) || 1,
      attrezzature: Array.isArray(attrezzature) ? attrezzature.map(a => a.trim()).filter(Boolean) : [],
      note: note ? note.trim() : '',
      attiva: Boolean(attiva),
      createdBy: req.user.userId
    });

    await newPostazione.save();
    
    // Popola per risposta
    const postazioneCompleta = await Postazione.findById(newPostazione._id)
      .populate('poloId', 'nome descrizione')
      .populate('createdBy', 'username');
    
    res.status(201).json({
      message: 'Postazione creata con successo',
      postazione: postazioneCompleta
    });
  } catch (error) {
    if (error.code === 11000) {
      return res.status(400).json({ 
        message: 'Postazione con questo nome gi√† esistente per questo polo'
      });
    }
    console.error('‚ùå Errore creazione postazione:', error);
    res.status(400).json({ message: error.message });
  }
});

// PUT - Modifica postazione (Admin)
app.put('/api/postazioni/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { 
      nome, 
      descrizione, 
      poloId, // ‚Üê CAMBIATO
      indirizzo,
      coordinate,
      capacitaPersone,
      attrezzature,
      note,
      attiva
    } = req.body;

    // Validazioni
    if (!nome || !poloId) {
      return res.status(400).json({ message: 'Nome e poloId sono obbligatori' });
    }

    // Verifica se la postazione esiste
    const postazione = await Postazione.findById(id);
    if (!postazione) {
      return res.status(404).json({ message: 'Postazione non trovata' });
    }

    // Verifica che il polo esista
    const polo = await Polo.findById(poloId);
    if (!polo) {
      return res.status(404).json({ message: 'Polo non trovato' });
    }

    // Verifica se nome √® gi√† usato da altra postazione nello stesso polo
    const existingPostazione = await Postazione.findOne({
      _id: { $ne: id },
      nome: { $regex: new RegExp('^' + nome.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'i') },
      poloId
    });

    if (existingPostazione) {
      return res.status(400).json({ 
        message: 'Un\'altra postazione ha gi√† questo nome per questo polo' 
      });
    }

    // Aggiorna postazione
    const updatedPostazione = await Postazione.findByIdAndUpdate(
      id,
      {
        nome: nome.trim(),
        descrizione: descrizione ? descrizione.trim() : '',
        poloId,
        indirizzo: indirizzo ? indirizzo.trim() : '',
        coordinate: coordinate || postazione.coordinate,
        capacitaPersone: capacitaPersone !== undefined ? parseInt(capacitaPersone) || 1 : postazione.capacitaPersone,
        attrezzature: Array.isArray(attrezzature) ? attrezzature.map(a => a.trim()).filter(Boolean) : postazione.attrezzature,
        note: note !== undefined ? (note ? note.trim() : '') : postazione.note,
        attiva: attiva !== undefined ? Boolean(attiva) : postazione.attiva
      },
      { new: true }
    )
    .populate('poloId', 'nome descrizione')
    .populate('createdBy', 'username');

    res.json({
      message: 'Postazione aggiornata con successo',
      postazione: updatedPostazione
    });
  } catch (error) {
    if (error.code === 11000) {
      return res.status(400).json({ 
        message: 'Una postazione con questo nome esiste gi√† per questo polo'
      });
    }
    console.error('‚ùå Errore aggiornamento postazione:', error);
    res.status(400).json({ message: error.message });
  }
});

// DELETE - Elimina postazione (Admin)
app.delete('/api/postazioni/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;

    // Verifica se la postazione esiste
    const postazione = await Postazione.findById(id)
      .populate('poloId', 'nome');

    if (!postazione) {
      return res.status(404).json({ message: 'Postazione non trovata' });
    }

    // Verifica se ci sono assegnazioni associate
    const assegnazioniCount = await Assegnazione.countDocuments({ postazioneId: id });
    if (assegnazioniCount > 0) {
      return res.status(400).json({ 
        message: 'Impossibile eliminare: ci sono ' + assegnazioniCount + ' assegnazioni associate a questa postazione.'
      });
    }

    // Elimina postazione
    await Postazione.findByIdAndDelete(id);

    res.json({
      message: 'Postazione eliminata con successo',
      deletedPostazione: {
        id: postazione._id,
        nome: postazione.nome,
        polo: postazione.poloId?.nome || 'N/A'
      }
    });
  } catch (error) {
    console.error('‚ùå Errore eliminazione postazione:', error);
    res.status(500).json({ message: error.message });
  }
});

// PATCH - Toggle stato attivo postazione (Admin)
app.patch('/api/postazioni/:id/toggle', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { attiva } = req.body;

    // Verifica se la postazione esiste
    const postazione = await Postazione.findById(id);
    if (!postazione) {
      return res.status(404).json({ message: 'Postazione non trovata' });
    }

    // Aggiorna stato
    const updatedPostazione = await Postazione.findByIdAndUpdate(
      id,
      { attiva: Boolean(attiva) },
      { new: true }
    )
    .populate('poloId', 'nome descrizione')
    .populate('createdBy', 'username');

    res.json({
      message: 'Postazione ' + (attiva ? 'attivata' : 'disattivata') + ' con successo',
      postazione: updatedPostazione
    });
  } catch (error) {
    console.error('‚ùå Errore toggle postazione:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET - Statistiche postazioni
app.get('/api/postazioni/stats', authenticateToken, async (req, res) => {
  try {
    const { poloId } = req.query;
    
    const filter = {};
    if (poloId) filter.poloId = poloId;
    
    const postazioni = await Postazione.find(filter);
    
    const stats = {
      totalePostazioni: postazioni.length,
      postazioniAttive: postazioni.filter(p => p.attiva).length,
      postazioniInattive: postazioni.filter(p => !p.attiva).length,
      capacitaTotale: postazioni.reduce((sum, p) => sum + (p.capacitaPersone || 0), 0),
      capacitaMedia: postazioni.length > 0 ? 
        Math.round(postazioni.reduce((sum, p) => sum + (p.capacitaPersone || 0), 0) / postazioni.length * 100) / 100 : 0,
      attrezzatureUniche: [...new Set(postazioni.flatMap(p => p.attrezzature || []))],
      postazioniConCoordinate: postazioni.filter(p => p.coordinate?.lat && p.coordinate?.lng).length
    };
    
    // Statistiche per polo
    const statsByPolo = {};
    for (const postazione of postazioni) {
      if (postazione.poloId) {
        const polo = await Polo.findById(postazione.poloId);
        if (polo) {
          const key = polo.nome;
          if (!statsByPolo[key]) {
            statsByPolo[key] = {
              totale: 0,
              attive: 0,
              capacitaTotale: 0
            };
          }
          statsByPolo[key].totale++;
          if (postazione.attiva) statsByPolo[key].attive++;
          statsByPolo[key].capacitaTotale += postazione.capacitaPersone || 0;
        }
      }
    }
    
    res.json({
      ...stats,
      perPolo: statsByPolo // ‚Üê CAMBIATO: da perSettimana a perPolo
    });
  } catch (error) {
    console.error('‚ùå Errore statistiche postazioni:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Copia postazioni da un polo all'altro (Admin)
app.post('/api/postazioni/copy', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { fromPoloId, toPoloId } = req.body; // ‚Üê CAMBIATO: da settimane a poli
    
    if (!fromPoloId || !toPoloId) {
      return res.status(400).json({ 
        message: 'fromPoloId e toPoloId sono richiesti' 
      });
    }
    
    // Verifica che entrambi i poli esistano
    const fromPolo = await Polo.findById(fromPoloId);
    const toPolo = await Polo.findById(toPoloId);
    
    if (!fromPolo || !toPolo) {
      return res.status(404).json({ message: 'Uno o entrambi i poli non esistono' });
    }
    
    // Trova postazioni del polo di origine
    const sourcePostazioni = await Postazione.find({
      poloId: fromPoloId,
      attiva: true
    });
    
    const copiedPostazioni = [];
    const skippedPostazioni = [];
    
    for (const sourcePostazione of sourcePostazioni) {
      // Verifica se esiste gi√† nel polo di destinazione
      const existingPostazione = await Postazione.findOne({
        nome: { $regex: new RegExp('^' + sourcePostazione.nome.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'i') },
        poloId: toPoloId
      });
      
      if (!existingPostazione) {
        // Crea nuova postazione
        const newPostazione = new Postazione({
          nome: sourcePostazione.nome,
          descrizione: sourcePostazione.descrizione,
          poloId: toPoloId,
          indirizzo: sourcePostazione.indirizzo,
          coordinate: sourcePostazione.coordinate,
          capacitaPersone: sourcePostazione.capacitaPersone,
          attrezzature: [...(sourcePostazione.attrezzature || [])],
          note: `Copiata da polo ${fromPolo.nome}`,
          attiva: true,
          createdBy: req.user.userId
        });
        
        await newPostazione.save();
        copiedPostazioni.push(newPostazione);
      } else {
        skippedPostazioni.push(sourcePostazione.nome);
      }
    }
    
    res.json({
      message: `Operazione completata`,
      copiate: copiedPostazioni.length,
      saltate: skippedPostazioni.length,
      dettagli: {
        copiate: copiedPostazioni.map(p => p.nome),
        saltate: skippedPostazioni,
        daPolo: fromPolo.nome,
        aPolo: toPolo.nome
      }
    });
  } catch (error) {
    console.error('‚ùå Errore copia postazioni:', error);
    res.status(400).json({ message: error.message });
  }
});

// =====================================================
// ROTTE API PER GESTIONE CLIENTI
// =====================================================

// GET - Lista tutti i clienti
app.get('/api/clienti', authenticateToken, async (req, res) => {
  try {
    const clienti = await Cliente.find({ attivo: true })
      .sort({ nome: 1 });
    res.json(clienti);
  } catch (error) {
    console.error('‚ùå Errore caricamento clienti:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET - Dettaglio cliente singolo
app.get('/api/clienti/:id', authenticateToken, async (req, res) => {
  try {
    const cliente = await Cliente.findById(req.params.id);
    if (!cliente) {
      return res.status(404).json({ message: 'Cliente non trovato' });
    }
    res.json(cliente);
  } catch (error) {
    console.error('‚ùå Errore caricamento cliente:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Crea nuovo cliente
app.post('/api/clienti', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { nome, email, telefono, indirizzo, citta, cap, partitaIva, codiceFiscale, note } = req.body;

    if (!nome) {
      return res.status(400).json({ message: 'Il nome del cliente √® obbligatorio' });
    }

    const nuovoCliente = new Cliente({
      nome,
      email,
      telefono,
      indirizzo,
      citta,
      cap,
      partitaIva,
      codiceFiscale,
      note
    });

    await nuovoCliente.save();
    console.log('‚úÖ Cliente creato:', nuovoCliente.nome);
    res.status(201).json(nuovoCliente);
  } catch (error) {
    console.error('‚ùå Errore creazione cliente:', error);
    res.status(400).json({ message: error.message });
  }
});

// PUT - Modifica cliente
app.put('/api/clienti/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { nome, email, telefono, indirizzo, citta, cap, partitaIva, codiceFiscale, note } = req.body;

    const cliente = await Cliente.findById(req.params.id);
    if (!cliente) {
      return res.status(404).json({ message: 'Cliente non trovato' });
    }

    if (nome !== undefined) cliente.nome = nome;
    if (email !== undefined) cliente.email = email;
    if (telefono !== undefined) cliente.telefono = telefono;
    if (indirizzo !== undefined) cliente.indirizzo = indirizzo;
    if (citta !== undefined) cliente.citta = citta;
    if (cap !== undefined) cliente.cap = cap;
    if (partitaIva !== undefined) cliente.partitaIva = partitaIva;
    if (codiceFiscale !== undefined) cliente.codiceFiscale = codiceFiscale;
    if (note !== undefined) cliente.note = note;

    await cliente.save();
    console.log('‚úÖ Cliente modificato:', cliente.nome);
    res.json(cliente);
  } catch (error) {
    console.error('‚ùå Errore modifica cliente:', error);
    res.status(400).json({ message: error.message });
  }
});

// DELETE - Elimina cliente (soft delete)
app.delete('/api/clienti/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const cliente = await Cliente.findById(req.params.id);
    if (!cliente) {
      return res.status(404).json({ message: 'Cliente non trovato' });
    }

    cliente.attivo = false;
    await cliente.save();

    console.log('‚úÖ Cliente eliminato (soft):', cliente.nome);
    res.json({ message: 'Cliente eliminato con successo', cliente });
  } catch (error) {
    console.error('‚ùå Errore eliminazione cliente:', error);
    res.status(400).json({ message: error.message });
  }
});

// =====================================================
// ROTTE API PER GESTIONE ORDINI
// =====================================================

// GET - Lista tutti gli ordini con filtri

app.get('/api/ordini', authenticateToken, async (req, res) => {
  try {
    const { 
      stato, 
      priorita, 
      cliente, 
      dataInizio, 
      dataFine, 
      citta, 
      assegnato,
      page = 1, 
      limit = 50 
    } = req.query;
    
    const filter = { attivo: true };
    
    // Filtri
    if (stato) filter.stato = stato;
    if (priorita) filter.priorita = priorita;
    if (cliente) filter.cliente = { $regex: cliente, $options: 'i' };
    if (citta) filter['indirizzo.citta'] = { $regex: citta, $options: 'i' };
    
    // Filtro per data consegna
    if (dataInizio || dataFine) {
      filter.dataConsegna = {};
      if (dataInizio) filter.dataConsegna.$gte = new Date(dataInizio);
      if (dataFine) filter.dataConsegna.$lte = new Date(dataFine);
    }
    
    // Filtro per ordini assegnati/non assegnati
    if (assegnato === 'true') {
      filter.stato = { $in: ['ASSEGNATO', 'IN_CORSO', 'COMPLETATO'] };
    } else if (assegnato === 'false') {
      filter.stato = 'CREATO';
    }
    
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    const [ordini, totale] = await Promise.all([
      Ordine.find(filter)
        .sort({ dataConsegna: 1, priorita: 1, createdAt: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .populate('createdBy', 'username')
        .populate('operatoreId', 'username email'),
      Ordine.countDocuments(filter)
    ]);
    
    res.json({
      ordini,
      paginazione: {
        pagina: parseInt(page),
        limite: parseInt(limit),
        totale,
        pagine: Math.ceil(totale / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Errore caricamento ordini:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET - Dettaglio singolo ordine
app.get('/api/ordini/:id', authenticateToken, async (req, res) => {
  try {
    const ordine = await Ordine.findById(req.params.id)
      .populate('createdBy', 'username email');
    
    if (!ordine) {
      return res.status(404).json({ message: 'Ordine non trovato' });
    }
    
    // üîç DEBUG: Ordine restituito dal GET
    console.log('üîç DEBUG GET Ordini: Ordine restituito:', {
      numero: ordine.numero,
      prodotti: ordine.prodotti?.map(p => ({
        nome: p.nome,
        quantita: p.quantita,
        quantitaMinima: p.quantitaMinima || 'NON DEFINITA'
      })) || []
    });
    
    // Trova eventuale assegnazione
    const assegnazione = await Assegnazione.findOne({
      'ordini.ordineId': ordine._id,
      attiva: true
    })
    .populate('userId', 'username email')
    .populate('poloId', 'nome')
    .populate('mezzoId', 'nome')
    .populate('settimanaId', 'numero anno dataInizio dataFine');
    
    res.json({
      ordine,
      assegnazione: assegnazione ? {
        id: assegnazione._id,
        operatore: assegnazione.userId,
        polo: assegnazione.poloId,
        mezzo: assegnazione.mezzoId,
        settimana: assegnazione.settimanaId,
        dettagliOrdine: assegnazione.ordini.find(o => 
          o.ordineId.toString() === ordine._id.toString()
        )
      } : null
    });
  } catch (error) {
    console.error('Errore caricamento ordine:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Crea nuovo ordine
app.post('/api/ordini', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const {
      numero,
      cliente,
      descrizione,
      dataConsegna,
      indirizzo,
      priorita,
      note,
      prodotti,
      valore,
      tempoStimato,
      operatoreId,
      assegnazioneId
    } = req.body;
    
    // Validazioni
    if (!numero || !cliente || !dataConsegna) {
      return res.status(400).json({ 
        message: 'Campi obbligatori: numero, cliente, dataConsegna' 
      });
    }
    
    // Controlla numero ordine univoco
    const esistente = await Ordine.findOne({ numero });
    if (esistente) {
      return res.status(400).json({ 
        message: 'Numero ordine gi√† esistente' 
      });
    }
    
    const ordine = new Ordine({
      numero,
      cliente,
      descrizione,
      dataConsegna: new Date(dataConsegna),
      indirizzo,
      priorita: priorita || 'MEDIA',
      note,
      prodotti: prodotti || [],
      valore: parseFloat(valore) || 0,
      tempoStimato: parseInt(tempoStimato) || 60,
      createdBy: req.user.userId,
      operatoreId: operatoreId || null // Salva operatore anche senza assegnazione
    });

    await ordine.save();

    // Se √® stata fornita un'assegnazione, collega l'ordine
    if (assegnazioneId) {
      const assegnazione = await Assegnazione.findById(assegnazioneId);
      if (assegnazione && assegnazione.attiva) {
        // Aggiorna l'assegnazione aggiungendo il riferimento all'ordine (numero)
        assegnazione.ordine = numero;
        await assegnazione.save();
      }
    }
    
    // RIMOSSO: Le giacenze vengono aggiornate solo alla finalizzazione dell'ordine
    
    const ordinePopolato = await Ordine.findById(ordine._id)
      .populate('createdBy', 'username');
    
    res.status(201).json({
      message: 'Ordine creato con successo',
      ordine: ordinePopolato
    });
  } catch (error) {
    console.error('Errore creazione ordine:', error);
    res.status(400).json({ message: error.message });
  }
});

// PUT - Modifica ordine esistente
app.put('/api/ordini/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    // üîç DEBUG: Log dei prodotti ricevuti
    if (req.body.prodotti) {
      console.log('üîç DEBUG PUT Ordini: Prodotti ricevuti:', req.body.prodotti.map(p => ({
        nome: p.nome,
        quantita: p.quantita,
        quantitaMinima: p.quantitaMinima || 'NON DEFINITA'
      })));
    }
    
    // Controlla se l'ordine √® gi√† assegnato
    const assegnazione = await Assegnazione.findOne({
      'ordini.ordineId': id,
      'ordini.stato': { $in: ['IN_CORSO', 'COMPLETATO'] },
      attiva: true
    });
    
    if (assegnazione) {
      return res.status(400).json({ 
        message: 'Impossibile modificare ordine gi√† in corso o completato',
        assegnazione: {
          operatore: assegnazione.userId,
          stato: assegnazione.ordini.find(o => o.ordineId.toString() === id).stato
        }
      });
    }
    
    const ordine = await Ordine.findByIdAndUpdate(
      id,
      req.body,
      { new: true, runValidators: true }
    ).populate('createdBy', 'username');
    
    if (!ordine) {
      return res.status(404).json({ message: 'Ordine non trovato' });
    }
    
    // üîç DEBUG: Ordine salvato nel DB
    console.log('üîç DEBUG PUT Ordini - SALVATO NEL DB:', {
      numero: ordine.numero,
      prodotti: ordine.prodotti?.map(p => ({
        nome: p.nome,
        quantita: p.quantita,
        quantitaMinima: p.quantitaMinima || 'NON DEFINITA'
      })) || []
    });
    
    res.json({
      message: 'Ordine aggiornato con successo',
      ordine
    });
  } catch (error) {
    console.error('Errore aggiornamento ordine:', error);
    res.status(400).json({ message: error.message });
  }
});

// POST - Finalizza ordine (cambia stato a COMPLETATO e incrementa giacenze GLOBALI)
app.post('/api/ordini/:id/finalize', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Trova l'ordine
    const ordine = await Ordine.findById(id);
    if (!ordine) {
      return res.status(404).json({ message: 'Ordine non trovato' });
    }
    
    // üîç DEBUG: Ordine caricato per finalizzazione
    console.log('üîç DEBUG FINALIZZAZIONE: Ordine caricato dal DB:', {
      numero: ordine.numero,
      prodotti: ordine.prodotti?.map(p => ({
        nome: p.nome,
        quantita: p.quantita,
        quantitaMinima: p.quantitaMinima || 'NON DEFINITA'
      })) || []
    });
    
    // Verifica che l'ordine non sia gi√† COMPLETATO
    if (ordine.stato === 'COMPLETATO') {
      return res.status(400).json({ message: 'Ordine gi√† completato' });
    }

    // Cerca assegnazione (facoltativa)
    const assegnazione = await Assegnazione.findOne({
      ordine: ordine.numero,
      attiva: true
    }).populate('userId');

    // Determina operatoreId: da assegnazione o direttamente dall'ordine
    let operatoreId;
    if (assegnazione) {
      operatoreId = assegnazione.userId._id || assegnazione.userId;
    } else if (ordine.operatoreId) {
      operatoreId = ordine.operatoreId;
      console.log('üìù Finalizzazione senza assegnazione - usando operatoreId dall\'ordine:', operatoreId);
    } else {
      return res.status(400).json({ message: 'Nessun operatore trovato per questo ordine (n√© assegnazione n√© operatoreId)' });
    }
    
    // DEBUG: Controlla giacenze globali esistenti
    const giacenzeGlobaliEsistenti = await GiacenzaUtente.find({ isGlobale: true, attiva: true }).populate('productId', 'nome');
    console.log(`üîç DEBUG: Giacenze globali esistenti (${giacenzeGlobaliEsistenti.length}):`, giacenzeGlobaliEsistenti.map(g => `${g.productId?.nome}: ${g.quantitaDisponibile}`));
    
    // Incrementa le giacenze GLOBALI per ogni prodotto nell'ordine
    if (ordine.prodotti && ordine.prodotti.length > 0) {
      console.log(`üîç DEBUG: Prodotti nell'ordine da finalizzare:`, ordine.prodotti.map(p => ({
        nome: p.nome,
        quantita: p.quantita,
        quantitaMinima: p.quantitaMinima || 'NON DEFINITA'
      })));
      
      for (const prodotto of ordine.prodotti) {
        try {
          console.log(`üîç DEBUG: Processando prodotto:`, {
            nome: prodotto.nome,
            quantita: prodotto.quantita,
            quantitaMinima: prodotto.quantitaMinima
          });
          
          // Trova il prodotto usando il nome per ottenere il productId
          const product = await Product.findOne({ nome: prodotto.nome, attivo: true });
          if (!product) {
            console.warn(`‚ö†Ô∏è Prodotto non trovato: ${prodotto.nome}`);
            continue;
          }

          // DEBUG: Log della ricerca giacenza globale
          console.log(`üîç DEBUG: Cercando giacenza globale per prodotto ${prodotto.nome} (ID: ${product._id})`);
          
          // Trova o crea giacenza GLOBALE per questo prodotto
          let giacenza = await GiacenzaUtente.findOne({
            productId: product._id,
            isGlobale: true,
            attiva: true
          });
          
          console.log(`üîç DEBUG: Giacenza globale trovata:`, giacenza ? 'SI' : 'NO');
          
          // Trova o crea giacenza GLOBALE dell'OPERATORE
          let giacenzaOperatore = await GiacenzaUtente.findOne({
            productId: product._id,
            userId: operatoreId,
            attiva: true
            // Nessun filtro su settimanaId - giacenza globale operatore
          });
          
          if (giacenzaOperatore && giacenzaOperatore.quantitaDisponibile > 0) {
            // Prodotto gi√† in giacenza CON quantit√† > 0 - aggiorna SOLO quantitaDisponibile
            giacenzaOperatore.quantitaDisponibile += prodotto.quantita;
            // NON toccare quantitaAssegnata (rimane quella esistente)
            // Mantieni quantitaMinima esistente o usa quella del prodotto se specificata
            if (prodotto.quantitaMinima !== undefined && prodotto.quantitaMinima > giacenzaOperatore.quantitaMinima) {
              giacenzaOperatore.quantitaMinima = prodotto.quantitaMinima;
            }
            await giacenzaOperatore.save();
            console.log(`‚úÖ Finalizzazione ordine - prodotto ${prodotto.nome} gi√† in giacenza: +${prodotto.quantita} (totale disp: ${giacenzaOperatore.quantitaDisponibile}, assegnata invariata: ${giacenzaOperatore.quantitaAssegnata}, min: ${giacenzaOperatore.quantitaMinima})`);
          } else {
            // Prodotto NON in giacenza O con giacenza = 0 - crea/aggiorna giacenza
            // quantitaAssegnata = quantitaDaAggiungere
            if (giacenzaOperatore) {
              // Giacenza esiste ma con quantit√† = 0 - aggiorna
              giacenzaOperatore.quantitaDisponibile = prodotto.quantita;
              giacenzaOperatore.quantitaAssegnata = prodotto.quantita; // Prende valore da "quantitaDaAggiungere"
              if (prodotto.quantitaMinima !== undefined) {
                giacenzaOperatore.quantitaMinima = prodotto.quantitaMinima;
              }
              await giacenzaOperatore.save();
              console.log(`‚úÖ Aggiornata giacenza a 0 per operatore ${assegnazione.userId.username} prodotto ${prodotto.nome}: disp=${giacenzaOperatore.quantitaDisponibile}, assegnata=${giacenzaOperatore.quantitaAssegnata}, min=${giacenzaOperatore.quantitaMinima}`);
            } else {
              // Crea completamente nuova giacenza
              giacenzaOperatore = new GiacenzaUtente({
                userId: operatoreId,
                productId: product._id,
                quantitaDisponibile: prodotto.quantita,
                quantitaAssegnata: prodotto.quantita, // Prende valore da "quantitaDaAggiungere"
                quantitaMinima: prodotto.quantitaMinima || 0,
                attiva: true,
                isGlobale: true, // Giacenza globale dell'operatore
                note: `Giacenza globale creata dalla finalizzazione ordine ${ordine.numero}`,
                assegnatoDa: req.user.userId
                // Nessun settimanaId - giacenza globale operatore
              });
              await giacenzaOperatore.save();
              console.log(`‚úÖ Creata nuova giacenza globale per operatore (ID: ${operatoreId}) prodotto ${prodotto.nome}: disp=${giacenzaOperatore.quantitaDisponibile}, assegnata=${giacenzaOperatore.quantitaAssegnata}, min=${giacenzaOperatore.quantitaMinima}`);
            }
          }
          
          // üîç DEBUG: Verifica giacenza salvata
          const giacenzaVerifica = await GiacenzaUtente.findById(giacenzaOperatore._id);
          console.log(`üîç VERIFICA POST-SALVATAGGIO - Giacenza ${prodotto.nome}:`, {
            quantitaDisponibile: giacenzaVerifica.quantitaDisponibile,
            quantitaAssegnata: giacenzaVerifica.quantitaAssegnata,
            quantitaMinima: giacenzaVerifica.quantitaMinima,
            isGlobale: giacenzaVerifica.isGlobale
          });
        } catch (prodottoError) {
          console.error(`Errore aggiornamento giacenze globali per prodotto ${prodotto.nome}:`, prodottoError);
        }
      }
    }
    
    // Cambia stato a COMPLETATO
    ordine.stato = 'COMPLETATO';
    await ordine.save();
    
    console.log(`‚úÖ Ordine ${ordine.numero} finalizzato con successo e giacenze globali incrementate`);
    
    res.json({
      message: 'Ordine finalizzato con successo e giacenze globali aggiornate',
      ordine: ordine
    });
  } catch (error) {
    console.error('Errore finalizzazione ordine:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Riapri ordine completato (cambia stato a CREATO e ripristina giacenze GLOBALI)
app.post('/api/ordini/:id/reopen', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Trova l'ordine
    const ordine = await Ordine.findById(id);
    if (!ordine) {
      return res.status(404).json({ message: 'Ordine non trovato' });
    }
    
    // Verifica che l'ordine sia COMPLETATO
    if (ordine.stato !== 'COMPLETATO') {
      return res.status(400).json({ message: 'Solo gli ordini completati possono essere riaperti' });
    }

    // Cerca assegnazione (facoltativa)
    const assegnazione = await Assegnazione.findOne({
      ordine: ordine.numero,
      attiva: true
    }).populate('userId');

    // Determina operatoreId: da assegnazione o direttamente dall'ordine
    let operatoreId;
    if (assegnazione) {
      operatoreId = assegnazione.userId._id || assegnazione.userId;
    } else if (ordine.operatoreId) {
      operatoreId = ordine.operatoreId;
      console.log('üìù Riapertura ordine senza assegnazione - usando operatoreId dall\'ordine:', operatoreId);
    } else {
      return res.status(400).json({ message: 'Nessun operatore trovato per questo ordine (n√© assegnazione n√© operatoreId)' });
    }

    // Decrementa le giacenze OPERATORE per ogni prodotto nell'ordine
    if (ordine.prodotti && ordine.prodotti.length > 0) {
      for (const prodotto of ordine.prodotti) {
        try {
          // Trova il prodotto usando il nome per ottenere il productId
          const product = await Product.findOne({ nome: prodotto.nome, attivo: true });
          if (!product) {
            console.warn(`‚ö†Ô∏è Prodotto non trovato nel database: ${prodotto.nome}`);
            continue;
          }

          // Trova la giacenza dell'OPERATORE per questo prodotto
          const giacenza = await GiacenzaUtente.findOne({
            productId: product._id,
            userId: operatoreId,
            isGlobale: true,  // Giacenze operative globali dell'operatore
            attiva: true
          });
          
          if (giacenza) {
            const giacenzaPrima = giacenza.quantitaDisponibile;
            
            // Sottrai la quantit√† dalle giacenze globali
            giacenza.quantitaDisponibile -= prodotto.quantita;
            giacenza.quantitaAssegnata -= prodotto.quantita;
            
            // Assicurati che non vadano sotto zero
            if (giacenza.quantitaDisponibile < 0) {
              giacenza.quantitaDisponibile = 0;
            }
            if (giacenza.quantitaAssegnata < 0) {
              giacenza.quantitaAssegnata = 0;
            }
            
            await giacenza.save();
            console.log(`üîÑ Decrementate giacenze operatore per prodotto ${prodotto.nome}: ${giacenzaPrima} ‚Üí ${giacenza.quantitaDisponibile} (-${prodotto.quantita})`);
          } else {
            console.warn(`‚ö†Ô∏è Giacenza operatore non trovata per prodotto ${prodotto.nome} - impossibile decrementare`);
          }
        } catch (prodottoError) {
          console.error(`‚ùå Errore decremento giacenze operatore per prodotto ${prodotto.nome}:`, prodottoError);
        }
      }
    }
    
    // Cambia stato a CREATO
    ordine.stato = 'CREATO';
    await ordine.save();
    
    console.log(`‚úÖ Ordine ${ordine.numero} riaperto con successo, giacenze operatore decrementate`);
    
    res.json({
      message: 'Ordine riaperto con successo e giacenze operatore decrementate',
      ordine: ordine
    });
  } catch (error) {
    console.error('Errore riapertura ordine:', error);
    res.status(500).json({ message: error.message });
  }
});

// DELETE - Elimina ordine (hard delete)
app.delete('/api/ordini/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Controlla se l'ordine √® assegnato
    const assegnazione = await Assegnazione.findOne({
      'ordini.ordineId': id,
      attiva: true
    });
    
    if (assegnazione) {
      return res.status(400).json({ 
        message: 'Impossibile eliminare ordine assegnato. Rimuovere prima dall\'assegnazione.',
        assegnazione: {
          id: assegnazione._id,
          operatore: assegnazione.userId
        }
      });
    }
    
    // HARD DELETE: Rimuovi fisicamente l'ordine dal database
    const ordine = await Ordine.findByIdAndDelete(id);
    
    if (!ordine) {
      return res.status(404).json({ message: 'Ordine non trovato' });
    }
    
    res.json({ 
      message: 'Ordine eliminato definitivamente dal database',
      ordineDeletato: {
        id: ordine._id,
        numero: ordine.numero,
        cliente: ordine.cliente
      }
    });
  } catch (error) {
    console.error('Errore eliminazione ordine:', error);
    res.status(500).json({ message: error.message });
  }
});

// =====================================================
// ROTTE API PER ASSEGNAZIONI AGGIORNATE
// =====================================================

// GET - Lista assegnazioni (aggiornata per includere ordini)
app.get('/api/assegnazioni', authenticateToken, async (req, res) => {
  try {
    const { 
      userId, 
      poloId, 
      mezzoId, 
      settimanaId, 
      attiva,
      conOrdini // nuovo filtro
    } = req.query;
    
    const filter = {};
    
    if (userId) filter.userId = userId;
    if (poloId) filter.poloId = poloId;
    if (mezzoId) filter.mezzoId = mezzoId;
    if (settimanaId) filter.settimanaId = settimanaId;
    
    if (attiva === 'true') {
      filter.attiva = true;
    } else if (attiva === 'false') {
      filter.attiva = false;
    }
    
    // Filtro per assegnazioni con/senza ordini
    if (conOrdini === 'true') {
      filter.ordine = { $exists: true, $ne: null };
    } else if (conOrdini === 'false') {
      filter.ordine = { $exists: false };
    }
    
    const assegnazioni = await Assegnazione.find(filter)
      .populate('userId', 'username email')
      .populate('poloId', 'nome')
      .populate('mezzoId', 'nome')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .populate('postazioneId', 'nome')
      .populate('ordine', 'numero cliente dataConsegna priorita stato valore')
      .populate('rdt', 'numero cliente dataConsegna priorita stato valore')
      .sort({ createdAt: -1 });
    
    // Debug logging per verificare populate
    console.log('üîç Assegnazioni con populate:', assegnazioni.slice(0, 2).map(a => ({
      _id: a._id,
      ordine: a.ordine,
      rdt: a.rdt
    })));
    
    res.json(assegnazioni);
  } catch (error) {
    console.error('Errore caricamento assegnazioni:', error);
    res.status(500).json({ message: error.message });
  }
});

// POST - Crea assegnazione (aggiornata)
app.post('/api/assegnazioni', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { userId, poloId, settimanaId, mezzoId, ordini = [] } = req.body;

    // Validazioni esistenti per operatore e polo
    const existingUserAssignment = await Assegnazione.findOne({
      userId, settimanaId, attiva: true
    });
    if (existingUserAssignment) {
      return res.status(400).json({ message: 'Operatore gi√† assegnato per questa settimana' });
    }

    const existingPoloAssignments = await Assegnazione.find({
      poloId, settimanaId, attiva: true
    });
    if (existingPoloAssignments.length >= 2) {
      return res.status(400).json({ message: 'Polo al completo (max 2 operatori)' });
    }

    // ‚úÖ NUOVO: Validazione ordini se forniti
    if (ordini && ordini.length > 0) {
      for (const ordineData of ordini) {
        const { ordineId } = ordineData;
        
        // Controlla se l'ordine esiste
        const ordine = await Ordine.findById(ordineId);
        if (!ordine) {
          return res.status(400).json({ 
            message: `Ordine ${ordineId} non trovato` 
          });
        }
        
        // Controlla se l'ordine √® gi√† assegnato
        const giaAssegnato = await Assegnazione.findOne({
          'ordini.ordineId': ordineId,
          attiva: true
        });
        if (giaAssegnato) {
          return res.status(400).json({ 
            message: `Ordine ${ordine.numero} gi√† assegnato`,
            assegnatoA: giaAssegnato.userId
          });
        }
        
        // Aggiorna stato ordine
        await Ordine.findByIdAndUpdate(ordineId, { stato: 'ASSEGNATO' });
      }
    }

    // Crea assegnazione
    const assegnazione = new Assegnazione({
      userId,
      poloId, 
      mezzoId,
      settimanaId,
      postazioneId: req.body.postazioneId,
      ordini: ordini.map((o, index) => ({
        ordineId: o.ordineId,
        priorita: o.priorita || (index + 1),
        tempoStimato: o.tempoStimato,
        note: o.note || ''
      })),
      createdBy: req.user.userId
    });
    
    await assegnazione.save();
    
    const populated = await Assegnazione.findById(assegnazione._id)
      .populate('userId', 'username email')
      .populate('poloId', 'nome')
      .populate('mezzoId', 'nome')
      .populate('settimanaId', 'numero anno dataInizio dataFine')
      .populate('ordini.ordineId', 'numero cliente dataConsegna priorita valore');
    
    res.status(201).json({
      message: 'Assegnazione creata con successo',
      assegnazione: populated
    });
  } catch (error) {
    console.error('Errore creazione assegnazione:', error);
    res.status(400).json({ message: error.message });
  }
});

// =====================================================
// ROTTE SPECIFICHE PER GESTIONE ORDINI IN ASSEGNAZIONI
// =====================================================

// POST - Aggiungi ordine a assegnazione esistente
app.post('/api/assegnazioni/:id/ordini', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { ordineId, priorita, tempoStimato, note } = req.body;
    
    const assegnazione = await Assegnazione.findById(id);
    if (!assegnazione) {
      return res.status(404).json({ message: 'Assegnazione non trovata' });
    }
    
    // Controlla se l'ordine esiste ed √® disponibile
    const ordine = await Ordine.findById(ordineId);
    if (!ordine) {
      return res.status(404).json({ message: 'Ordine non trovato' });
    }
    
    if (ordine.stato !== 'CREATO') {
      return res.status(400).json({ 
        message: 'Ordine non disponibile per assegnazione',
        statoAttuale: ordine.stato
      });
    }
    
    // Controlla se gi√† assegnato altrove
    const giaAssegnato = await Assegnazione.findOne({
      ordine: ordineId,
      attiva: true
    });
    if (giaAssegnato) {
      return res.status(400).json({ 
        message: 'Ordine gi√† assegnato ad altro operatore' 
      });
    }
    
    // Controlla se l'assegnazione ha gi√† un ordine
    if (assegnazione.ordine && assegnazione.ordine !== ordineId) {
      return res.status(400).json({ 
        message: 'Assegnazione ha gi√† un ordine collegato. Usare una nuova assegnazione.' 
      });
    }
    
    // Aggiungi ordine all'assegnazione (assicurati che sia ObjectId)
    assegnazione.ordine = new mongoose.Types.ObjectId(ordineId);
    await assegnazione.save();
    
    // Aggiorna stato ordine
    await Ordine.findByIdAndUpdate(ordineId, { stato: 'ASSEGNATO' });
    
    const updated = await Assegnazione.findById(id)
      .populate('userId', 'username email')
      .populate('poloId', 'nome')
      .populate('settimanaId', 'numero anno');
    
    res.json({
      message: 'Ordine aggiunto all\'assegnazione',
      assegnazione: updated
    });
  } catch (error) {
    console.error('Errore aggiunta ordine:', error);
    res.status(400).json({ message: error.message });
  }
});

// DELETE - Rimuovi ordine da assegnazione
app.delete('/api/assegnazioni/:id/ordini/:ordineId', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id, ordineId } = req.params;
    
    const assegnazione = await Assegnazione.findById(id);
    if (!assegnazione) {
      return res.status(404).json({ message: 'Assegnazione non trovata' });
    }
    
    const ordineNellAssegnazione = assegnazione.ordini.find(
      o => o.ordineId.toString() === ordineId
    );
    
    if (!ordineNellAssegnazione) {
      return res.status(404).json({ message: 'Ordine non trovato in questa assegnazione' });
    }
    
    // Non permettere rimozione se in corso o completato
    if (['IN_CORSO', 'COMPLETATO'].includes(ordineNellAssegnazione.stato)) {
      return res.status(400).json({ 
        message: 'Impossibile rimuovere ordine in corso o completato',
        stato: ordineNellAssegnazione.stato
      });
    }
    
    // Rimuovi ordine dall'assegnazione
    await assegnazione.rimuoviOrdine(ordineId);
    
    // Ripristina stato ordine
    await Ordine.findByIdAndUpdate(ordineId, { stato: 'CREATO' });
    
    res.json({
      message: 'Ordine rimosso dall\'assegnazione con successo'
    });
  } catch (error) {
    console.error('Errore rimozione ordine:', error);
    res.status(400).json({ message: error.message });
  }
});

// PATCH - Aggiorna stato ordine in assegnazione
app.patch('/api/assegnazioni/:id/ordini/:ordineId/stato', authenticateToken, async (req, res) => {
  try {
    const { id, ordineId } = req.params;
    const { stato, note } = req.body;
    
    if (!['ASSEGNATO', 'IN_CORSO', 'COMPLETATO', 'ANNULLATO'].includes(stato)) {
      return res.status(400).json({ 
        message: 'Stato non valido',
        statiValidi: ['ASSEGNATO', 'IN_CORSO', 'COMPLETATO', 'ANNULLATO']
      });
    }
    
    const assegnazione = await Assegnazione.findById(id);
    if (!assegnazione) {
      return res.status(404).json({ message: 'Assegnazione non trovata' });
    }
    
    // Controlla autorizzazioni: admin o operatore proprietario
    if (req.user.role !== 'admin' && assegnazione.userId.toString() !== req.user.userId) {
      return res.status(403).json({ message: 'Non autorizzato' });
    }
    
    await assegnazione.aggiornaStatoOrdine(ordineId, stato, note);
    
    // Aggiorna anche lo stato nell'ordine principale se necessario
    const mappingStati = {
      'ASSEGNATO': 'ASSEGNATO',
      'IN_CORSO': 'IN_CORSO', 
      'COMPLETATO': 'COMPLETATO',
      'ANNULLATO': 'CREATO' // se annullato, torna disponibile
    };
    
    await Ordine.findByIdAndUpdate(ordineId, { 
      stato: mappingStati[stato] 
    });
    
    const updated = await Assegnazione.findById(id)
      .populate('ordini.ordineId', 'numero cliente dataConsegna');
    
    res.json({
      message: 'Stato ordine aggiornato',
      assegnazione: updated
    });
  } catch (error) {
    console.error('Errore aggiornamento stato:', error);
    res.status(400).json({ message: error.message });
  }
});

// PATCH - Riordina priorit√† ordini in assegnazione
app.patch('/api/assegnazioni/:id/ordini/priorita', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { nuovoOrdine } = req.body; // Array di { ordineId, priorita }
    
    const assegnazione = await Assegnazione.findById(id);
    if (!assegnazione) {
      return res.status(404).json({ message: 'Assegnazione non trovata' });
    }
    
    await assegnazione.riordinaPriorita(nuovoOrdine);
    
    const updated = await Assegnazione.findById(id)
      .populate('ordini.ordineId', 'numero cliente dataConsegna');
    
    res.json({
      message: 'Priorit√† ordini aggiornata',
      assegnazione: updated
    });
  } catch (error) {
    console.error('Errore riordino priorit√†:', error);
    res.status(400).json({ message: error.message });
  }
});

// =====================================================
// ROTTE DI RICERCA E STATISTICHE
// =====================================================

// GET - Ordini disponibili per assegnazione
app.get('/api/ordini/disponibili', authenticateToken, async (req, res) => {
  try {
    const { 
      settimanaId, 
      poloId, 
      dataInizio, 
      dataFine,
      priorita,
      citta
    } = req.query;
    
    const filter = { 
      stato: 'CREATO',
      attivo: true 
    };
    
    // Filtri temporali
    if (dataInizio || dataFine) {
      filter.dataConsegna = {};
      if (dataInizio) filter.dataConsegna.$gte = new Date(dataInizio);
      if (dataFine) filter.dataConsegna.$lte = new Date(dataFine);
    }
    
    // Se specificata una settimana, filtra per quella settimana
    if (settimanaId) {
      const settimana = await Settimana.findById(settimanaId);
      if (settimana) {
        filter.dataConsegna = {
          $gte: new Date(settimana.dataInizio),
          $lte: new Date(settimana.dataFine)
        };
      }
    }
    
    if (priorita) filter.priorita = priorita;
    if (citta) filter['indirizzo.citta'] = { $regex: citta, $options: 'i' };
    
    const ordini = await Ordine.find(filter)
      .sort({ priorita: 1, dataConsegna: 1 })
      .limit(100);
    
    res.json({
      ordini,
      totale: ordini.length,
      filtri: { settimanaId, poloId, dataInizio, dataFine, priorita, citta }
    });
  } catch (error) {
    console.error('Errore caricamento ordini disponibili:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET - Ricerca ordini avanzata
app.get('/api/ordini/ricerca', authenticateToken, async (req, res) => {
  try {
    const { q, tipo = 'tutti' } = req.query; // q = query di ricerca
    
    if (!q || q.length < 2) {
      return res.status(400).json({ 
        message: 'Query di ricerca troppo breve (minimo 2 caratteri)' 
      });
    }
    
    const searchRegex = { $regex: q, $options: 'i' };
    const baseFilter = { attivo: true };
    
    // Filtri per tipo
    if (tipo === 'disponibili') {
      baseFilter.stato = 'CREATO';
    } else if (tipo === 'assegnati') {
      baseFilter.stato = { $in: ['ASSEGNATO', 'IN_CORSO'] };
    } else if (tipo === 'completati') {
      baseFilter.stato = 'COMPLETATO';
    }
    
    const ordini = await Ordine.find({
      ...baseFilter,
      $or: [
        { numero: searchRegex },
        { cliente: searchRegex },
        { descrizione: searchRegex },
        { 'indirizzo.via': searchRegex },
        { 'indirizzo.citta': searchRegex },
        { 'prodotti.nome': searchRegex }
      ]
    })
    .sort({ dataConsegna: 1, createdAt: -1 })
    .limit(50)
    .populate('createdBy', 'username');
    
    res.json({
      ordini,
      totale: ordini.length,
      query: q,
      tipo
    });
  } catch (error) {
    console.error('Errore ricerca ordini:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET - Dashboard statistiche ordini e assegnazioni
app.get('/api/dashboard/ordini-assegnazioni', authenticateToken, async (req, res) => {
  try {
    const { settimanaId } = req.query;
    
    // Statistiche generali ordini
    const statsOrdini = await Ordine.aggregate([
      { $match: { attivo: true } },
      {
        $group: {
          _id: '$stato',
          count: { $sum: 1 },
          valoreTotal: { $sum: '$valore' }
        }
      }
    ]);
    
    // Statistiche per settimana se specificata
    let statsSettimanali = null;
    if (settimanaId) {
      statsSettimanali = await Assegnazione.statisticheSettimanali(settimanaId);
    }
    
    // Top operatori per numero ordini
    const topOperatori = await Assegnazione.aggregate([
      { $match: { attiva: true } },
      { $unwind: '$ordini' },
      {
        $group: {
          _id: '$userId',
          totaleOrdini: { $sum: 1 },
          ordiniCompletati: {
            $sum: { $cond: [{ $eq: ['$ordini.stato', 'COMPLETATO'] }, 1, 0] }
          },
          valoreGestito: { $sum: '$stats.valoreCommercialeAssegnato' }
        }
      },
      {
        $lookup: {
          from: 'users',
          localField: '_id',
          foreignField: '_id',
          as: 'operatore'
        }
      },
      { $unwind: '$operatore' },
      {
        $project: {
          username: '$operatore.username',
          totaleOrdini: 1,
          ordiniCompletati: 1,
          valoreGestito: 1,
          percentualeCompletamento: {
            $multiply: [
              { $divide: ['$ordiniCompletati', '$totaleOrdini'] },
              100
            ]
          }
        }
      },
      { $sort: { totaleOrdini: -1 } },
      { $limit: 10 }
    ]);
    
    // Ordini per priorit√†
    const prioritaDistribution = await Ordine.aggregate([
      { $match: { attivo: true, stato: { $ne: 'COMPLETATO' } } },
      {
        $group: {
          _id: '$priorita',
          count: { $sum: 1 }
        }
      },
      { $sort: { _id: 1 } }
    ]);
    
    // Trend settimanale (ultimi 30 giorni)
    const trendOrdini = await Ordine.aggregate([
      {
        $match: {
          attivo: true,
          createdAt: { $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) }
        }
      },
      {
        $group: {
          _id: {
            anno: { $year: '$createdAt' },
            mese: { $month: '$createdAt' },
            giorno: { $dayOfMonth: '$createdAt' }
          },
          ordiniCreati: { $sum: 1 },
          valoreGiornaliero: { $sum: '$valore' }
        }
      },
      { $sort: { '_id.anno': 1, '_id.mese': 1, '_id.giorno': 1 } }
    ]);
    
    res.json({
      statisticheOrdini: {
        perStato: statsOrdini,
        prioritaDistribution,
        trend: trendOrdini
      },
      statisticheSettimanali,
      topOperatori,
      dataGenerazione: new Date()
    });
  } catch (error) {
    console.error('Errore dashboard:', error);
    res.status(500).json({ message: error.message });
  }
});

// GET - Statistiche per operatore specifico
app.get('/api/operatori/:userId/statistiche-ordini', authenticateToken, async (req, res) => {
  try {
    const { userId } = req.params;
    const { settimanaId, mese, anno } = req.query;
    
    // Controlla autorizzazioni
    if (req.user.role !== 'admin' && req.user.userId !== userId) {
      return res.status(403).json({ message: 'Non autorizzato' });
    }
    
    const matchFilter = { userId: new mongoose.Types.ObjectId(userId), attiva: true };
    
    // Filtri temporali per assegnazioni
    if (settimanaId) {
      matchFilter.settimanaId = new mongoose.Types.ObjectId(settimanaId);
    }
    
    const stats = await Assegnazione.aggregate([
      { $match: matchFilter },
      { $unwind: { path: '$ordini', preserveNullAndEmptyArrays: true } },
      {
        $lookup: {
          from: 'ordini',
          localField: 'ordini.ordineId',
          foreignField: '_id',
          as: 'dettagliOrdine'
        }
      },
      { $unwind: { path: '$dettagliOrdine', preserveNullAndEmptyArrays: true } },
      {
        $group: {
          _id: null,
          totaleAssegnazioni: { $sum: 1 },
          totaleOrdini: { 
            $sum: { $cond: [{ $ne: ['$ordini', null] }, 1, 0] }
          },
          ordiniCompletati: {
            $sum: { $cond: [{ $eq: ['$ordini.stato', 'COMPLETATO'] }, 1, 0] }
          },
          valoreGestito: { $sum: '$dettagliOrdine.valore' },
          tempoTotaleStimato: { $sum: '$ordini.tempoStimato' }
        }
      },
      {
        $project: {
          totaleAssegnazioni: 1,
          totaleOrdini: 1,
          ordiniCompletati: 1,
          valoreGestito: 1,
          tempoTotaleStimato: 1,
          percentualeCompletamento: {
            $cond: [
              { $gt: ['$totaleOrdini', 0] },
              { $multiply: [{ $divide: ['$ordiniCompletati', '$totaleOrdini'] }, 100] },
              0
            ]
          },
          mediaValorePerOrdine: {
            $cond: [
              { $gt: ['$totaleOrdini', 0] },
              { $divide: ['$valoreGestito', '$totaleOrdini'] },
              0
            ]
          }
        }
      }
    ]);
    
    res.json({
      operatoreId: userId,
      statistiche: stats[0] || {
        totaleAssegnazioni: 0,
        totaleOrdini: 0,
        ordiniCompletati: 0,
        valoreGestito: 0,
        tempoTotaleStimato: 0,
        percentualeCompletamento: 0,
        mediaValorePerOrdine: 0
      },
      periodo: { settimanaId, mese, anno }
    });
  } catch (error) {
    console.error('Errore statistiche operatore:', error);
    res.status(500).json({ message: error.message });
  }
});

// =====================================================
// ROTTE BULK OPERATIONS
// =====================================================

// POST - Assegnazione batch di ordini
app.post('/api/assegnazioni/batch', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { assegnazioni } = req.body;
    // assegnazioni = [{ userId, poloId, mezzoId, settimanaId, ordiniIds: [] }]
    
    if (!Array.isArray(assegnazioni) || assegnazioni.length === 0) {
      return res.status(400).json({ 
        message: 'Array di assegnazioni richiesto' 
      });
    }
    
    const risultati = [];
    const errori = [];
    
    for (const [index, assegnazioneData] of assegnazioni.entries()) {
      try {
        const { userId, poloId, mezzoId, settimanaId, ordiniIds = [] } = assegnazioneData;
        
        // Validazioni per questa assegnazione
        const existingUserAssignment = await Assegnazione.findOne({
          userId, settimanaId, attiva: true
        });
        
        if (existingUserAssignment) {
          errori.push({
            index,
            errore: `Operatore ${userId} gi√† assegnato per settimana ${settimanaId}`
          });
          continue;
        }
        
        // Crea assegnazione
        const assegnazione = new Assegnazione({
          userId,
          poloId,
          mezzoId,
          settimanaId,
          ordini: ordiniIds.map((ordineId, idx) => ({
            ordineId,
            priorita: idx + 1
          })),
          createdBy: req.user.userId
        });
        
        await assegnazione.save();
        
        // Aggiorna stati ordini
        await Ordine.updateMany(
          { _id: { $in: ordiniIds } },
          { stato: 'ASSEGNATO' }
        );
        
        risultati.push({
          index,
          assegnazioneId: assegnazione._id,
          ordiniAssegnati: ordiniIds.length
        });
        
      } catch (error) {
        errori.push({
          index,
          errore: error.message
        });
      }
    }
    
    res.json({
      message: 'Operazione batch completata',
      successi: risultati.length,
      errori: errori.length,
      dettagli: { risultati, errori }
    });
    
  } catch (error) {
    console.error('Errore assegnazione batch:', error);
    res.status(500).json({ message: error.message });
  }
});

// =====================================================
// UTILITY ENDPOINTS
// =====================================================

// GET - Controlla conflitti per una potenziale assegnazione
app.post('/api/assegnazioni/verifica-conflitti', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { userId, poloId, settimanaId, mezzoId, ordiniIds = [] } = req.body;
    
    const conflitti = [];
    
    // Verifica operatore
    const conflittoOperatore = await Assegnazione.findOne({
      userId, settimanaId, attiva: true
    });
    if (conflittoOperatore) {
      conflitti.push({
        tipo: 'OPERATORE_GIA_ASSEGNATO',
        messaggio: 'Operatore gi√† assegnato per questa settimana',
        dettagli: { assegnazioneId: conflittoOperatore._id }
      });
    }
    
    // Verifica polo al completo
    const assegnazioniPolo = await Assegnazione.find({
      poloId, settimanaId, attiva: true
    });
    if (assegnazioniPolo.length >= 2) {
      conflitti.push({
        tipo: 'POLO_COMPLETO',
        messaggio: 'Polo al completo (massimo 2 operatori)',
        dettagli: { 
          assegnazioniEsistenti: assegnazioniPolo.length,
          massimo: 2
        }
      });
    }
    
    // Verifica mezzo
    const conflittoMezzo = await Assegnazione.findOne({
      mezzoId, settimanaId, attiva: true
    });
    if (conflittoMezzo) {
      conflitti.push({
        tipo: 'MEZZO_GIA_ASSEGNATO',
        messaggio: 'Mezzo gi√† assegnato per questa settimana',
        dettagli: { assegnazioneId: conflittoMezzo._id }
      });
    }
    
    // Verifica ordini
    for (const ordineId of ordiniIds) {
      const ordineAssegnato = await Assegnazione.findOne({
        'ordini.ordineId': ordineId,
        attiva: true
      });
      if (ordineAssegnato) {
        const ordine = await Ordine.findById(ordineId);
        conflitti.push({
          tipo: 'ORDINE_GIA_ASSEGNATO',
          messaggio: `Ordine ${ordine?.numero} gi√† assegnato`,
          dettagli: { 
            ordineId,
            numeroOrdine: ordine?.numero,
            assegnazioneId: ordineAssegnato._id
          }
        });
      }
    }
    
    res.json({
      hasConflitti: conflitti.length > 0,
      conflitti,
      valido: conflitti.length === 0
    });
    
  } catch (error) {
    console.error('Errore verifica conflitti:', error);
    res.status(500).json({ message: error.message });
  }
});

// DEBUG: Endpoint temporaneo per verificare giacenze globali
app.get('/api/debug/giacenze-globali', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const giacenzeGlobali = await GiacenzaUtente.find({
      isGlobale: true,
      attiva: true
    }).populate('productId', 'nome categoria').populate('userId', 'username');
    
    console.log(`üîç DEBUG: Trovate ${giacenzeGlobali.length} giacenze globali`);
    
    res.json({
      count: giacenzeGlobali.length,
      giacenze: giacenzeGlobali.map(g => ({
        id: g._id,
        prodotto: g.productId?.nome || 'Prodotto non trovato',
        quantitaDisponibile: g.quantitaDisponibile,
        quantitaAssegnata: g.quantitaAssegnata,
        utente: g.userId?.username || 'Utente non trovato',
        isGlobale: g.isGlobale,
        note: g.note
      }))
    });
  } catch (error) {
    console.error('Errore debug giacenze globali:', error);
    res.status(500).json({ error: error.message });
  }
});

// =====================================================
// ADMIN TOOLS - Reset Giacenze Operatore
// =====================================================

app.post('/api/admin/reset-giacenze-operatore', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { resetGiacenzeOperatore } = require('./resetGiacenzeOperatore');
    
    console.log('üîÑ Avvio reset giacenze operatore tramite API...');
    
    await resetGiacenzeOperatore();
    
    const stats = await GiacenzaUtente.aggregate([
      {
        $group: {
          _id: null,
          count: { $sum: 1 },
          totalAssegnata: { $sum: '$quantitaAssegnata' },
          totalDisponibile: { $sum: '$quantitaDisponibile' },
          avgAssegnata: { $avg: '$quantitaAssegnata' },
          avgDisponibile: { $avg: '$quantitaDisponibile' }
        }
      }
    ]);
    
    const giacenzeGlobali = await GiacenzaUtente.countDocuments({ isGlobale: true });
    const giacenzeConSettimana = await GiacenzaUtente.countDocuments({ settimanaId: { $ne: null } });
    
    res.json({
      success: true,
      message: 'Reset giacenze operatore completato con successo',
      stats: stats[0] || {},
      details: {
        giacenzeGlobali,
        giacenzeConSettimana,
        giacenzeConNote: await GiacenzaUtente.countDocuments({ note: { $ne: '' } })
      }
    });
    
  } catch (error) {
    console.error('‚ùå Errore reset giacenze operatore:', error);
    res.status(500).json({
      success: false,
      message: 'Errore durante il reset delle giacenze operatore',
      error: error.message
    });
  }
});

// GET - Statistiche giacenze operatore
app.get('/api/admin/giacenze-stats', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const totalGiacenze = await GiacenzaUtente.countDocuments();
    const giacenzeAttive = await GiacenzaUtente.countDocuments({ attiva: true });
    const giacenzeGlobali = await GiacenzaUtente.countDocuments({ isGlobale: true });
    const giacenzeConSettimana = await GiacenzaUtente.countDocuments({ settimanaId: { $ne: null } });
    
    const quantitaStats = await GiacenzaUtente.aggregate([
      {
        $group: {
          _id: null,
          totalAssegnata: { $sum: '$quantitaAssegnata' },
          totalDisponibile: { $sum: '$quantitaDisponibile' },
          avgAssegnata: { $avg: '$quantitaAssegnata' },
          avgDisponibile: { $avg: '$quantitaDisponibile' },
          minAssegnata: { $min: '$quantitaAssegnata' },
          maxAssegnata: { $max: '$quantitaAssegnata' }
        }
      }
    ]);
    
    const utentiConGiacenze = await GiacenzaUtente.aggregate([
      { $group: { _id: '$userId', count: { $sum: 1 } } },
      { $group: { _id: null, utenti: { $sum: 1 }, avgGiacenzePerUtente: { $avg: '$count' } } }
    ]);
    
    res.json({
      totali: {
        totalGiacenze,
        giacenzeAttive,
        giacenzeGlobali,
        giacenzeConSettimana
      },
      quantita: quantitaStats[0] || {},
      utenti: utentiConGiacenze[0] || { utenti: 0, avgGiacenzePerUtente: 0 }
    });
    
  } catch (error) {
    console.error('Errore nel recupero delle statistiche:', error);
    res.status(500).json({ error: error.message });
  }
});

// Avvia il server
app.listen(process.env.PORT, '0.0.0.0', async () => {
  console.log(`üöÄ Server giacenze multi-settimana su porta ${PORT}`);
  console.log(`üîë JWT Secret: ${JWT_SECRET ? 'Configurato' : 'ERRORE: Mancante!'}`);
  console.log(`üóÑÔ∏è  MongoDB: ${MONGODB_URI}`);
  console.log(`üåê Test API: http://localhost:${PORT}/api/test`);
  
  // Inizializza dati di test se il database √® vuoto
  await initTestData();
});